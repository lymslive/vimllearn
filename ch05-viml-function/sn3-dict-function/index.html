<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      
    

      <title></title>

      
      

      <!-- CSS -->
      
      <link rel="stylesheet" href="https://lymslive.github.io/vimllearn/book.css">
      

      
      
    </head>

    <body>
        <div class="menu">
            
            
            <nav role="navigation">
                <ul>
                    
                        
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch00-prefcace/">
                                    
                                    前言
                                </a>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/">
                                    
                                    第一章 VimL 语言主要特点
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn1-hello-world/">
                                                    
                                                    1.1 Hello World 的四种写法
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn2-from-ex-command/">
                                                    
                                                    1.2 同源 ex 命令行
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn3-week-type-strong-scope/">
                                                    
                                                    1.3 弱类型强作用域
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn4-autoload-schema/">
                                                    
                                                    1.4 自动加载脚本机制
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/">
                                    
                                    第二章 VimL 语言基本语法
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn1-variable-type/">
                                                    
                                                    2.1 变量与类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn2-comapare-condition/">
                                                    
                                                    2.2 选择与比较
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn3-loop-iterate/">
                                                    
                                                    2.3 循环与迭代
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn4-function-call/">
                                                    
                                                    2.4 函数定义与使用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn5-exception-error/">
                                                    
                                                    2.5 异常处理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/">
                                    
                                    第三章 Vim 常用命令
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn1-option-set/">
                                                    
                                                    3.1 选项设置
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn2-key-remap/">
                                                    
                                                    3.2 快捷键重映射
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn3-custom-command/">
                                                    
                                                    3.3 自定义命令
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn4-execute-normal/">
                                                    
                                                    3.4 execute 与 normal
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn5-autocmd-event/">
                                                    
                                                    3.5 自动命令与事件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn6-debug-command/">
                                                    
                                                    3.6 调试命令
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/">
                                    
                                    第四章 VimL 数据结构进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn1-list-string/">
                                                    
                                                    4.1 再谈列表与字符串
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn2-dictionary/">
                                                    
                                                    4.2 通用的字典结构
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn3-nest-compose/">
                                                    
                                                    4.3 嵌套组合与扩展
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn4-regex-apply/">
                                                    
                                                    4.4 正则表达式
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/">
                                    
                                    第五章 VimL 函数进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn1-variable-argument/">
                                                    
                                                    5.1 可变参数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn2-function-refer/">
                                                    
                                                    5.2 函数引用
                                                </a>
                                            </li>
                                        
                                            <li class="active">
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn3-dict-function/">
                                                    
                                                    5.3 字典函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn4-closure-lambda/">
                                                    
                                                    5.4 闭包函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn5-autoload-function/">
                                                    
                                                    5.5 自动函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/">
                                    
                                    第六章 VimL 内建函数使用
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn1-operate-datatype/">
                                                    
                                                    6.1 操作数据类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn2-operate-edit-object/">
                                                    
                                                    6.2 操作编辑对象
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn3-operate-filesystem/">
                                                    
                                                    6.3 操作系统文件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn4-other-utility/">
                                                    
                                                    6.4 其他实用函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/">
                                    
                                    第七章 VimL 面向对象编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn1-object-intro/">
                                                    
                                                    7.1 面向对象的简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn2-dict-object/">
                                                    
                                                    7.2 字典即对象 
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn3-object-organize/">
                                                    
                                                    7.3 自定义类的组织管理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/">
                                    
                                    第八章 VimL 异步编程特性
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn1-asynchronous-intro/">
                                                    
                                                    8.1 异步工作简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn2-asynchronous-job/">
                                                    
                                                    8.2 使用异步任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn3-channle-job/">
                                                    
                                                    8.3 使用通道控制任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn4-internal-terminal/">
                                                    
                                                    8.4 使用配置内置终端
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/">
                                    
                                    第九章 VimL 混合编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn1-extern-filter/">
                                                    
                                                    9.1 用外部语言写过滤器
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn2-extern-interface/">
                                                    
                                                    9.2 外部语言接口编程
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn3-perl-interface/">
                                                    
                                                    9.3 Perl 语言接口开发
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/">
                                    
                                    第十章 Vim 插件管理与开发
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn1-plugin-directory/">
                                                    
                                                    10.1 典型插件的目录规范
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn2-plugin-manager/">
                                                    
                                                    10.2 插件管理器插件介绍
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn3-plugin-devflow/">
                                                    
                                                    10.3 插件开发流程指引
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/chA1-postfcace/">
                                    
                                    结语
                                </a>
                                
                            </li>
                        
                    
                </ul>
            </nav>
            
            
        </div>

        <div class="page">
            <div class="page__header">
                <div class="menu-icon">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                
                <span class="search-icon">🔎</span>
                
            </div>

            <div class="page__content">
                
                <div class="search-container">
                    <input id="search" type="search" placeholder="Search..">
                    <div class="search-results">
                        <div class="search-results__header"></div>
                        <ul class="search-results__items"></ul>
                    </div>
                </div>
                
                <div class="book-content">
                    
    <h1>5.3 字典函数</h1>
    <!-- ## 5.3 字典函数 -->
<p>函数引用能保存在字典，这不意外，上节就提到过，脚本内定义的 <code>s:</code> 前缀变量（包括
函数引用），就自动保存在 <code>s:</code> 这个特殊字典中。关键是如何主动利用这个特性，为编
程需求带来便利。在本节中，将保存在字典中的函数引用简称为字典函数。</p>
<h3 id="jiang-yi-you-han-shu-bao-cun-zai-zi-dian-zhong">将已有函数保存在字典中</h3>
<p>沿用上节的示例，将函数引用保存在字典中，相关代码改写如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/funcref.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:dOperator</span><span> = {</span><span style="color:#a3be8c;">&#39;desc&#39;</span><span>: </span><span style="color:#a3be8c;">&#39;some function on varargins&#39;</span><span>}
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#a3be8c;">&#39;+&#39;</span><span>] = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;s:sum&#39;</span><span>)
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#a3be8c;">&#39;*&#39;</span><span>] = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;s:prod&#39;</span><span>)
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">CalculateD</span><span>(operator, </span><span style="color:#b48ead;">...</span><span>) abort
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:Fnr</span><span> = </span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>operator]
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:result</span><span> = </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#bf616a;">l:Fnr</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:result
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>这里先定义了一个字典变量 <code>s:dOperator</code>，并用键 <code>+</code> 保存函数 <code>s:sum()</code> 的引用
，用键 <code>*</code> 保存函数 <code>s:prod()</code> 的引用。然后改写 <code>CalculateD()</code> 函数就很简洁了
，根据传入的第一参数索引字典，获得相应的函数引用，再调用之。因为直接用键索引字
典，且认为没有遍历全部键的需求，所以还可以在 <code>s:dOperator</code> 字典加入非函数引用
的键，比如 <code>desc</code> 保存了一条描述，字符串类型。</p>
<p>可以在命令行中输入 <code>:echo CalculateD('*', 1, 2, 3, 4)</code> 测验一下。注意到该函数
没有检查传入参数是否有效的键，如 <code>:echo CalculateD('**', 1, 2, 3, 4)</code> 会报错。
可以先用 <code>has_key()</code> 内置函数检查参数 <code>a:operator</code> 是否存在的键，更进一步，可
再用 <code>type()</code> 函数与该键相关联的值是否函数引用。如果参数是非法的，则提前返回，
至于返回什么值表示错误，那就与具体需求有关了。也许在某些情况下，不检查参数，直
接让它在出错时终止脚本运行也是可接受的处理方式。</p>
<h3 id="an-cheng-yuan-de-fang-shi-yin-yong-han-shu">按成员的方式引用函数</h3>
<p>我们知道，字典元素有两种索引方式，一是用方括号（类似列表索引），一种是用点号（
类似成员索引）。不过后者只是前者的语法糖，要求键名是简单字符串（有效标志符）。
因此可以用一个较有意义单词键名来代替 <code>+</code> <code>*</code> 符号键名，例如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/funcref.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>sumFnr = </span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#a3be8c;">&#39;+&#39;</span><span>]
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>prodFnr = </span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#a3be8c;">&#39;*&#39;</span><span>]
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">sumFnr</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>)
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">prodFnr</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>)
</span></code></pre>
<p>如果之前没有在字典中定义 <code>+</code> 键，也可以直接用 <code>let s:dOperator.sumFnr = function('s:sum')</code> 获得函数引用。这里以小写字母开头的键名也可以保存函数引用。
然后调用函数的写法就是 <code>s:dOperator.sumFnr()</code>。由于使用的是脚本局部的字典变量
，须用 <code>:source</code> 命令重新加载脚本文件执行上例，观察这种调用方法的结果。</p>
<h3 id="zhi-jie-ding-yi-zi-dian-han-shu">直接定义字典函数</h3>
<p>为了在字典键中保存一个函数引用，之前其实分了三步工作：</p>
<ol>
<li>用 <code>:function</code> 命令定义一个函数；</li>
<li>用 <code>function()</code> 函数获取这个函数的引用；</li>
<li>用 <code>:let</code> 命令将这个函数引用赋值给字典的某个键。</li>
</ol>
<p>但这三步曲（实际是两条语句）可以合起来，直接在定义函数时就将其引用保存在字典中
，其语法示例如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/funcref.vim
</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">sum</span><span>(</span><span style="color:#b48ead;">...</span><span>)
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sum</span><span> = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">l:arg </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sum</span><span> += </span><span style="color:#bf616a;">l:arg
</span><span>    </span><span style="color:#b48ead;">endfor
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:sum
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">prod</span><span>(</span><span style="color:#b48ead;">...</span><span>)
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:prod</span><span> = </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">l:arg </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:prod</span><span> = </span><span style="color:#bf616a;">l:prod </span><span style="color:#b48ead;">* </span><span style="color:#bf616a;">l:arg
</span><span>    </span><span style="color:#b48ead;">endfor
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:prod
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">sum</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>)
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">prod</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>)
</span></code></pre>
<p>其实就相当于将之前的函数头 <code>:function s:sum(...)</code> 改为 <code>:function s:dOperator.sum(...)</code>，函数体功能实现完全一样。要注意的是在执行这一行之前，
<code>s:dOprator</code> 字典必须是已定义的。然后调用该函数的用法完全一样。</p>
<p>请注意区分一下，<code>s:dOperator.sumFnr</code> 显然是一个函数引用，它引用事先已定义的
<code>s:sum()</code> 函数。<code>s:dOperator.sum</code> 也是一个函数引用，它引用的又是哪个函数呢？
它引用的是即时定义的函数，它没有名字（没机会也没必要给个名字），也叫做匿名
函数。在 Vim 内部，它将给这样定义的匿名函数一个编号，所以也叫编号函数。</p>
<p>如果在脚本文件末尾写上 <code>echo s:</code> 这条语句，根据其输出结果，就能更清楚地分辨这
些函数引用变量的异同。例如，执行结果大概相当于如下定义：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#bf616a;">s:fnrSum</span><span> = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;SNR&gt;77_sum&#39;</span><span>)
</span><span style="color:#bf616a;">s:fnrProd</span><span> = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;SNR&gt;77_prod&#39;</span><span>)
</span><span>
</span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#a3be8c;">&#39;+&#39;</span><span>] = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;SNR&gt;77_sum&#39;</span><span>)
</span><span style="color:#bf616a;">s:dOperator</span><span>[</span><span style="color:#a3be8c;">&#39;*&#39;</span><span>] = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;SNR&gt;77_prod&#39;</span><span>)
</span><span>
</span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>sumFnr = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;SNR&gt;77_sum&#39;</span><span>)
</span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>prodFnr = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;SNR&gt;77_prod&#39;</span><span>)
</span><span>
</span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>sum = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;172&#39;</span><span>)
</span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>prod = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;173&#39;</span><span>)
</span></code></pre>
<p>因此，<code>s:fnrSum</code> <code>s:dOperator['+']</code> 与 <code>s:dOperator.sumFnr</code> 都是引用同一个函数
，那就是 <code>s:sum()</code> 局部函数，不过 vim 自动将其修正为 <code>&lt;SNR&gt;77_sum()</code> 全局函数
。而 <code>s:dOperator.sum</code> 则完全引用另一个函数，是编号为 <code>172</code> 的匿名函数。当然，
你的输出中，脚本编号与函数编号极可能是不一样的。</p>
<p>我们知道，退化的 <code>:function</code> 命令可以查看打印函数定义。所以可以用 <code>:function &lt;SNR&gt;77_sum</code> 在命令行直接执行，其输出应该与脚本中定义的 <code>s:sum()</code> 函数一致。但
是在命令行使用 <code>:function s:sum</code> 是错误。那匿名函数怎么查看呢，直接用编号作为
参数是不行的，需用一个大括号括起来，如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#b48ead;">function </span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_sum
</span><span>: </span><span style="color:#b48ead;">function</span><span> {</span><span style="color:#d08770;">173</span><span>}
</span></code></pre>
<p>但是，用于获取一个函数引用的 <code>function()</code> 却无有效方法仅从匿名函数的编号获得其
引用。如 <code>function('173')</code> 或 <code>function('{173}')</code> 都不能正常工作。匿名函数一般
必须在创建时赋值给某个函数引用变量，然后只能通过该函数引用调用之。当然了，该函
数引用可以再赋值给其他变量就是。</p>
<h3 id="zi-dian-han-shu-de-te-shu-shu-xing">字典函数的特殊属性</h3>
<p>如果仔细观察上述 <code>:function {173}</code> 命令输出，可以发现它在函数头定义行尾，自己
添加了一个关键字 <code>dict</code>，表示将要定义的函数具有 <code>dict</code> 属性。这个属性指出该函
数必须通过字典来激活调用，也就是说必须将其引用保存在字典的某个键中。然后在函数
体中，可以使用 <code>self</code> 这个关键字，它表示调用该函数时所用到的字典变量。</p>
<p>例如，假设我们要在上述 <code>s:dOperator</code> 字典中另外加一个计算圆面积的函数。从数学
上讲，圆面积只是其半径的函数，应该只要传入半径参数。但在程序中实现计算时，还要
涉及一个圆周率常量。这个常量不适合放在函数内定义，当然可以定义为 <code>s:</code> 脚本变量
，不过最好还是保存在同一个字典中。</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/funcref.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>PI = </span><span style="color:#d08770;">3</span><span style="color:#b48ead;">.</span><span style="color:#d08770;">14
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area</span><span>(r)
</span><span>    </span><span style="color:#b48ead;">return</span><span> self</span><span style="color:#b48ead;">.</span><span>PI </span><span style="color:#b48ead;">* </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>r </span><span style="color:#b48ead;">* </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>r
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area</span><span>(</span><span style="color:#d08770;">2</span><span>)
</span></code></pre>
<p>我们先定义了 <code>s:dOperator.area</code> 函数（引用），然后调用 <code>s:dOperator.area(2)</code> 来
计算半径为 <code>2</code> 的圆面积。在函数定义体内用到了 <code>self.PI</code>，这个 <code>self</code> 就是调用
该函数时所用到的字典变量，也即 <code>s:dOperator</code>。</p>
<p>这里，我们调用时与定义时用到的字典变量是同一个，但这不是必须的。比如，我们可以
创建另一个字典 <code>s:Math</code>，它保存了一个 <code>PI</code> 键，为示区别，这个 <code>PI</code> 保存的圆周
率精度大一些：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/funcref.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Math</span><span> = {}
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Math</span><span style="color:#b48ead;">.</span><span>PI = </span><span style="color:#d08770;">3</span><span style="color:#b48ead;">.</span><span style="color:#d08770;">14159
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Math</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">Area</span><span> = </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:Math</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">Area</span><span>(</span><span style="color:#d08770;">2</span><span>)
</span></code></pre>
<p>请观察 <code>s:dOperator.area(2)</code> 与 <code>s:Math.Area(2)</code> 计算结果的不同，表明后者调用
时 <code>self.PI</code> 确实用到了 <code>s:Math.PI</code> 的值，而不是 <code>s:dOperator.PI</code> 的值。而且，
在 <code>s:Math</code> 中的函数名 <code>Area</code> 不一定要与最初定义时所用的 <code>area</code> 相同。但是函数
体内用到的 <code>PI</code> 键名，必须相同。</p>
<p>如果把 <code>s:dOperator.area</code> 这个函数（引用）赋值给普通变量（非字典键），会发生什
么情况呢？尝试在脚本末尾继续添加如下代码并加载运行：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">g:Fnr</span><span> = </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">g:Fnr</span><span>(</span><span style="color:#d08770;">2</span><span>)
</span></code></pre>
<p>结果它会报 <code>E725</code> 错误，提出不能在没有字典的情况下调用具有 <code>dict</code> 属性的函数。
这似乎很好理解，因为在 <code>area()</code> 函数体内，用到了 <code>self.PI</code>，没有字典的话，这个
<code>self</code> 就无所引用了。实际上，即使在函数体内没有到用 <code>self</code> ，也不能绕过字典去
调用字典函数。比如原来的 <code>s:dOperator.sum()</code> 就没用到 <code>self</code>，但如下代码也时非
法的：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">g:Fnr</span><span> = </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>sum
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">g:Fnr</span><span>(</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>,</span><span style="color:#d08770;">4</span><span>)
</span></code></pre>
<p>在为 <code>g:Fnr</code> 赋值时不会出错，在调用 <code>g:Fnr()</code> 时才出错。所以 vim 是通过 <code>dict</code>
这个函数属性来检测调用合法性的，因为这种函数体内有可能用到 <code>self</code>，提前终止潜
在的错误，总是更安全的设计。而且，既然用到 <code>dict</code> ，就意味着大概率会用到 <code>self</code>，
否则将一个非 <code>dict</code> 属性的函数保存在字典中，是很无趣的（虽然合法）。以下语句却
不会出错：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">g:Fnr</span><span> = </span><span style="color:#bf616a;">s:dOperator</span><span style="color:#b48ead;">.</span><span>sumFnr
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">g:Fnr</span><span>(</span><span style="color:#d08770;">1</span><span>,</span><span style="color:#d08770;">2</span><span>,</span><span style="color:#d08770;">3</span><span>,</span><span style="color:#d08770;">4</span><span>)
</span></code></pre>
<p>因为 <code>s:dOperator.sumFnr</code> 所引用的函数其实是 <code>s:sum()</code>，它在定义时未指定 <code>dict</code>
属性。所以 <code>s:dOperator.sunFnr</code> 只起到一个传递变量值的中介作用，<code>g:Fnr</code> 也是
对 <code>s:sum()</code> 的函数引用，当然也就可以直接调用了。</p>
<h3 id="pu-tong-han-shu-de-zi-dian-shu-xing">普通函数的字典属性</h3>
<p>上面在定义 <code>s:dOperator.sum</code> 与 <code>s:dOperator.area</code> （对匿名函数的引用）时，并
未显式写出 <code>dict</code> 属性。这只是 <code>:function</code> 定义字典函数时的语法糖，vim 会自动
添加 <code>dict</code> 属性。</p>
<p>定义普通函数时也可以指定 <code>dict</code> 属性，例如我们另外写个计算矩形面积的函数：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:area</span><span>(width, height) dict
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>width </span><span style="color:#b48ead;">* </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>height
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#65737e;">&quot; echo s:area(3, 4) |&quot; 出错
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Rect</span><span> = {}
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area</span><span> = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;s:area&#39;</span><span>)
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area</span><span>(</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>) |</span><span style="color:#65737e;">&quot; 正确
</span></code></pre>
<p>但是，由于 <code>s:area()</code> 函数是 <code>dict</code> 属性的，所以直接调用 <code>s:area()</code> 会出误。必
须把它（的引用）放在一个字典中，如上为此专门建了个空字典变量 <code>s:Rect</code>，将函数
引用保存在其 <code>area</code> 键名中，才能调用 <code>s:Rect.area()</code>。</p>
<p>因此，当一个普通函数用了 <code>dict</code> 属性，却没用到 <code>self</code> 特性，好像用处不是很大，
反而限制了其正常使用。为此，将 <code>s:area()</code> 函数重新定义如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:area</span><span>() dict
</span><span>    </span><span style="color:#b48ead;">return</span><span> self</span><span style="color:#b48ead;">.</span><span>width </span><span style="color:#b48ead;">*</span><span> self</span><span style="color:#b48ead;">.</span><span>height
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span>width = </span><span style="color:#d08770;">3
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span>height = </span><span style="color:#d08770;">4
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span style="color:#96b5b4;">area</span><span>()
</span></code></pre>
<p>取消 <code>s:area()</code> 的函数参数，而将 <code>width</code> 与 <code>height</code> 参数保存在 <code>s:Rect</code> 字典
中，然后就可以无参调用 <code>s:Rect.area()</code> 了。这样，长、宽就相当于矩形（<code>s:Rect</code>）
的属性，而求面积的 <code>area()</code> 就相当于它的方法。这就初具面向对象的特征了（这将在
后续章节中再详细讨论）。</p>
<p>注意这里的 <code>s:area()</code> 函数体内用到了 <code>self</code>，则在函数头一定要指定 <code>dict</code> 属性
。反之则不强制要求。</p>
<p>具有 <code>dict</code> 属性的函数，除了对用字典键引用来调用外，也可以用 <code>call()</code> 函数间接
调用。之前已经介绍过 <code>call()</code> 函数，其实它还可接收第三个可选参数，按 <code>:help call()</code> 介绍其用法是 <code>call({func}, {arglist} [, {dict}])</code>。如果第一个参数（函
数名或函数引用）所指代的函数具有 <code>dict</code> 属性，第三个参数就应该提供一个字典传递
给这个函数体实现中的 <code>self</code> 变量。</p>
<p>因此，第二个版本（无参数）的 <code>s:area()</code> 可以这么调用：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#a3be8c;">&#39;s:area&#39;</span><span>, [], </span><span style="color:#bf616a;">s:Rect</span><span>)
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;s:area&#39;</span><span>), [], </span><span style="color:#bf616a;">s:Rect</span><span>)
</span></code></pre>
<p>这两条语句都合法，不过由于使用了 <code>s:area</code> 字符串，必须在脚本中才能运行。当
<code>call()</code> 在调用 <code>s:area()</code> 时，<code>s:area()</code> 函数内的 <code>self</code> 也就是 <code>s:Rect</code> 了。</p>
<p>至于第一个版本带两个参数的 <code>s:area()</code> 则可以这么调用：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#a3be8c;">&#39;s:area&#39;</span><span>, [</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">6</span><span>], {})
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#a3be8c;">&#39;s:area&#39;</span><span>, [</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">6</span><span>]) |</span><span style="color:#65737e;">&quot; 出错
</span></code></pre>
<p>将参数收集在一个列表变量中，作为第二参数传入。由于函数体内未用到 <code>self</code> ，在第
三参数随便提供一个字典变量就行，即使是个空字典 <code>{}</code>。但若不提供这个字典参数，
则会发生运行时错误。</p>
<h3 id="zhi-jie-ding-yi-zi-dian-han-shu-yu-jian-jie-ding-yi-de-bi-jiao">直接定义字典函数与间接定义的比较</h3>
<p>综上再小结一下，定义字典函数（引用）有两种方式。一是直接用一条语句搞定，字典键
引用了一个匿名函数；二是先定义函数，再将该有名函数的引用赋值给字典键。不妨分别
称之为直接定义与间接定义。</p>
<ul>
<li>直接定义：<code>function dict.method()</code></li>
<li>间接定义：<code>function Method()</code> 与 <code>let dict.method = function('Method')</code></li>
</ul>
<p>显然，直接定义的语法更简洁方便，请尽量使用这种语法。那么间接定义的写法还有没有
什么存在的意义呢？</p>
<p>首先，这可能是历史原因。VimL 也是随 Vim 逐步发展完善起来的，很有可能函数引用的
概念先于 <code>dict</code> 属性与 <code>self</code> 变量的引入。因而也就先有分步写的字典函数引用，然
后才有一步到位的语法糖写法。</p>
<p>其次，间接定义的函数引用有更灵活的控制权。直接定义的字典函数必定是匿名函数的引
用，且隐含具有 <code>dict</code> 的属性，不论是否显式写出该关键词。这也就意味着不能将直接
定义的字典函数引用赋值给普通函数引用变量，那是不能工作的。但在间接定义字典函数
时有更多的选择，在定义函数时可根据需要是否指定 <code>dict</code> 属性。没有 <code>dict</code> 属性的
函数引用可以赋值给普通变量。因此，从编码实践上建议：</p>
<ul>
<li>直接定义的字典函数，也始终显式加上 <code>dict</code> 关键词，不要太依赖语言的隐式作用。</li>
<li>普通函数，如果实现体中需要用到 <code>self</code> 才加 <code>dict</code> 属性关键词。</li>
</ul>
<p>最后，字典键名引用有名或匿名函数，会影响调试与错误信息。通过示例详细说明，将以
下代码片断添加到本节的演示脚本末尾，并用 <code>:source</code> 重新加载。</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/funcref.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">debug1</span><span>() dict abort
</span><span>    </span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;sfile&gt;&#39;</span><span>)
</span><span>    Hello Vim, 我在这里就是个错误
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:debug2</span><span>() abort
</span><span>    </span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;sfile&gt;&#39;</span><span>)
</span><span>    Hello Vim, 我来这里也是个错误
</span><span style="color:#b48ead;">endfunction
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span>debug</span><span style="color:#d08770;">2</span><span> = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;s:debug2&#39;</span><span>)
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">test</span><span>() dict </span><span style="color:#65737e;">&quot; abort
</span><span>    </span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;sfile&gt;&#39;</span><span>)
</span><span>    call self</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">debug1</span><span>()
</span><span>    call self</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">debug2</span><span>()
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:test</span><span>() abort
</span><span>    </span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;sfile&gt;&#39;</span><span>)
</span><span>    call </span><span style="color:#bf616a;">s:Rect</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">test</span><span>()
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Test</span><span>() abort
</span><span>    </span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;sfile&gt;&#39;</span><span>)
</span><span>    call </span><span style="color:#8fa1b3;">s:test</span><span>()
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;&lt;sfile&gt;&#39;</span><span>)
</span></code></pre>
<p>复用原来的字典 <code>s:Rect</code>，增加了两个函数引用键，其中 <code>debug1</code> 是直接定义的，
<code>debug2</code> 是间接引用 <code>s:debug2()</code> 的。这两个函数内随意加了一行错误语句。这在加
载脚本时并不会出错误，只有实际调用了相应函数才有机会出错。然后再定义了一个统一
的 <code>s:Rect.test()</code> 函数，在其内调用这两个 <code>debug</code> 函数。最后还定义了 <code>s:test()</code>
与 <code>Test()</code> 函数。只有 <code>Test()</code> 是全局的，可以在命令行中执行 <code>:call Test()</code> 查
看结果。在执行前先人工分析下这将发生的函数调用链：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>全局函数 Test() --&gt; 脚本函数 s:text() --&gt; 字典函数 s:Rect.test()
</span><span>[1] --&gt; 字典函数 s:Rect.debug1() | 引用匿名函数
</span><span>[2] --&gt; 字典函数 s:Rect.debug2() | 引用 s:debug2() 函数
</span></code></pre>
<p>我这里执行 <code>:call Test()</code> 后输出如下，脚本编号与函数编号肯定是依环境不同的：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span> Test
</span><span style="color:#b48ead;">function</span><span> Test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_test
</span><span style="color:#b48ead;">function</span><span> Test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">181
</span><span style="color:#b48ead;">function</span><span> Test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">181</span><span>[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">180
</span><span>Error detected </span><span style="color:#b48ead;">while</span><span> processing </span><span style="color:#b48ead;">function</span><span> Test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">181</span><span>[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">180</span><span>:
</span><span>line    </span><span style="color:#d08770;">2</span><span>:
</span><span>E</span><span style="color:#d08770;">492</span><span>: Not an editor </span><span style="color:#96b5b4;">command</span><span>:     Hello Vim, 我在这里就是个错误
</span><span style="color:#b48ead;">function</span><span> Test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">181</span><span>[</span><span style="color:#d08770;">3</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_debug</span><span style="color:#d08770;">2
</span><span>Error detected </span><span style="color:#b48ead;">while</span><span> processing </span><span style="color:#b48ead;">function</span><span> Test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_test[</span><span style="color:#d08770;">2</span><span>]</span><span style="color:#b48ead;">..</span><span style="color:#d08770;">181</span><span>[</span><span style="color:#d08770;">3</span><span>]</span><span style="color:#b48ead;">..</span><span>&lt;SNR&gt;</span><span style="color:#d08770;">77</span><span>_debug</span><span style="color:#d08770;">2</span><span>:
</span><span>line    </span><span style="color:#d08770;">2</span><span>:
</span><span>E</span><span style="color:#d08770;">492</span><span>: Not an editor </span><span style="color:#96b5b4;">command</span><span>:     Hello Vim, 我来这里也是个错误
</span></code></pre>
<p>其中，常规字体是各函数内 <code>echo expand('&lt;sfile&gt;')</code> 的正常输出，红字部分是错误语
句触发的输出，即 vim 自动给出的错误提示信息。主要是触发 <code>E492</code> 这个错误，它说
<code>Helle Vim</code> 不是编辑器的有效命令。并在之前先打印出错时所在的函数名与行号。重点
关注一下函数名的表示方法，例如在 <code>s:Rect.debug1()</code> 出错时的位置信息：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>function Test[2]..&lt;SNR&gt;77_test[2]..181[2]..180:
</span></code></pre>
<p>对比之前的分析，第一层调用是全局函数 <code>Test</code>，中括号 <code>[2]</code> 表示在第二行调用下一
层函数，即 <code>s:test()</code>，它被转化成 <code>&lt;SNR&gt;77_test</code> 函数名，然后第二行再调用
<code>s:Rect.test()</code> ，这是匿名函数，所以只能打印出编号 <code>181</code>，然后继续调用
<code>s:Rect.debug1()</code> ，它也是匿名函数，也只打印出编号 <code>180</code>。到这个函数就出错了，
没能再调用其他函数，出错行号另起一行打印出来。</p>
<p>在 <code>s:Rect.debug2()</code> 出错时的位置信息类似：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>function Test[2]..&lt;SNR&gt;77_test[2]..181[3]..&lt;SNR&gt;77_debug2:
</span></code></pre>
<p>只不过在倒数第二层的行号从第二行改为了第三行，最后一个函数名打印出了实际所引用
的函数名 <code>&lt;SNR&gt;77_debug2</code> ，也就是脚本中的 <code>s:debug()</code>。</p>
<p>这有什么差别呢？试想我们若用 VimL 开发实用功能（主要是插件时），调用链经常也会
这么长或者更长。当 vim 报错时，给出一长串错误提示，我们第一反应是想知道哪里出
错了，最终出错在哪个函数中。这反映在出错信息的最后一个调用函数，但是像
<code>s:Rect.debug1()</code> 这样的直接定义的字典函数，vim 只打印个 <code>180</code> 编号，可能完全
不知所云。而像 <code>s:Rect.debug2()</code> 这个间接定义的字典函数，它会打印出函数名。即
使你也不知脚本编号，那也是有迹可循，比如用 <code>:scriptnames</code> 检查。而且在实践中，
你也不可能在很多不同脚本中都定义了相当的函数，那么不用检查脚本编号也基本能定位
错误了。</p>
<p>还有重要一点，在开发 VimL 脚本过程中，如果修改 Bug 后重新加载脚本，那直接定义
的字典函数所引用的匿名函数编号是会变化的。因为它相当于重新定义了另一个匿名函数
并为字典键赋值，而原来那个匿名函数再无引用无可访问就会自动释放（垃圾回收机制）
。但是，脚本编号并不会改变，除非大重构把文件名也改了。这种编号的变化性对查 Bug
也多少会有影响的。</p>
<p>顺便提一下，也许你也注意到了，vim 自动打印的出错位置信息，其实就是 <code>&lt;sfile&gt;</code>
的值。如果用在函数中，那就是运行到该处时完整的调用链字符串；在不同时刻从不同入
口调用时还可能给出不同的值。但如果用在函数外，那就只能是在脚本文件中，<code>&lt;sfile&gt;</code>
就表示脚本文件名（故不能直接用在命令行中）。这也是 <code>sfile</code> 这个单词意义的来源
。不过你也可以将脚本整体理解为一个函数（也是一个执行单元），其“函数名”显然就是
脚本名了。</p>
<p>还有一点得注意，在定义 <code>s:Rect.test()</code> 函数时，没有加 <code>abort</code> 属性。按之前的建
议，定义函数时始终加 <code>abort</code> 是良好的习惯，因为它会在出错时立即终止运行，避免
更多的错乱。不过在这里，如果有 <code>abort</code> 属性，它在调用 <code>self.debug1()</code> 出错后就
立即终止，<code>self.debug2()</code> 也就没机会调用了。由于我们想对比出错信息，要求触发所
有错误，因而特意取消 <code>abort</code> 属性。</p>


                </div>
            </div>

            <div class="prev-link">
                
    
        
        
        <a class="previous" href="https://lymslive.github.io/vimllearn/ch05-viml-function/"><</a>
    

            </div>

            <div class="next-link">
                
    
        <a class="next" href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn4-closure-lambda/">></a>
    

            </div>
        </div>

        
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/elasticlunr.min.js"></script>
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/search_index.en.js"></script>
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/book.js"></script>
        
    </body>

</html>

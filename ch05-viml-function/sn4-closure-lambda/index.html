<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      
    

      <title></title>

      
      

      <!-- CSS -->
      
      <link rel="stylesheet" href="https://lymslive.github.io/vimllearn/book.css">
      

      
      
    </head>

    <body>
        <div class="menu">
            
            
            <nav role="navigation">
                <ul>
                    
                        
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch00-prefcace/">
                                    
                                    前言
                                </a>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/">
                                    
                                    第一章 VimL 语言主要特点
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn1-hello-world/">
                                                    
                                                    1.1 Hello World 的四种写法
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn2-from-ex-command/">
                                                    
                                                    1.2 同源 ex 命令行
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn3-week-type-strong-scope/">
                                                    
                                                    1.3 弱类型强作用域
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn4-autoload-schema/">
                                                    
                                                    1.4 自动加载脚本机制
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/">
                                    
                                    第二章 VimL 语言基本语法
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn1-variable-type/">
                                                    
                                                    2.1 变量与类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn2-comapare-condition/">
                                                    
                                                    2.2 选择与比较
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn3-loop-iterate/">
                                                    
                                                    2.3 循环与迭代
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn4-function-call/">
                                                    
                                                    2.4 函数定义与使用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn5-exception-error/">
                                                    
                                                    2.5 异常处理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/">
                                    
                                    第三章 Vim 常用命令
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn1-option-set/">
                                                    
                                                    3.1 选项设置
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn2-key-remap/">
                                                    
                                                    3.2 快捷键重映射
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn3-custom-command/">
                                                    
                                                    3.3 自定义命令
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn4-execute-normal/">
                                                    
                                                    3.4 execute 与 normal
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn5-autocmd-event/">
                                                    
                                                    3.5 自动命令与事件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn6-debug-command/">
                                                    
                                                    3.6 调试命令
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/">
                                    
                                    第四章 VimL 数据结构进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn1-list-string/">
                                                    
                                                    4.1 再谈列表与字符串
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn2-dictionary/">
                                                    
                                                    4.2 通用的字典结构
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn3-nest-compose/">
                                                    
                                                    4.3 嵌套组合与扩展
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn4-regex-apply/">
                                                    
                                                    4.4 正则表达式
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/">
                                    
                                    第五章 VimL 函数进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn1-variable-argument/">
                                                    
                                                    5.1 可变参数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn2-function-refer/">
                                                    
                                                    5.2 函数引用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn3-dict-function/">
                                                    
                                                    5.3 字典函数
                                                </a>
                                            </li>
                                        
                                            <li class="active">
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn4-closure-lambda/">
                                                    
                                                    5.4 闭包函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn5-autoload-function/">
                                                    
                                                    5.5 自动函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/">
                                    
                                    第六章 VimL 内建函数使用
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn1-operate-datatype/">
                                                    
                                                    6.1 操作数据类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn2-operate-edit-object/">
                                                    
                                                    6.2 操作编辑对象
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn3-operate-filesystem/">
                                                    
                                                    6.3 操作系统文件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn4-other-utility/">
                                                    
                                                    6.4 其他实用函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/">
                                    
                                    第七章 VimL 面向对象编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn1-object-intro/">
                                                    
                                                    7.1 面向对象的简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn2-dict-object/">
                                                    
                                                    7.2 字典即对象 
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn3-object-organize/">
                                                    
                                                    7.3 自定义类的组织管理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/">
                                    
                                    第八章 VimL 异步编程特性
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn1-asynchronous-intro/">
                                                    
                                                    8.1 异步工作简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn2-asynchronous-job/">
                                                    
                                                    8.2 使用异步任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn3-channle-job/">
                                                    
                                                    8.3 使用通道控制任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn4-internal-terminal/">
                                                    
                                                    8.4 使用配置内置终端
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/">
                                    
                                    第九章 VimL 混合编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn1-extern-filter/">
                                                    
                                                    9.1 用外部语言写过滤器
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn2-extern-interface/">
                                                    
                                                    9.2 外部语言接口编程
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn3-perl-interface/">
                                                    
                                                    9.3 Perl 语言接口开发
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/">
                                    
                                    第十章 Vim 插件管理与开发
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn1-plugin-directory/">
                                                    
                                                    10.1 典型插件的目录规范
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn2-plugin-manager/">
                                                    
                                                    10.2 插件管理器插件介绍
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn3-plugin-devflow/">
                                                    
                                                    10.3 插件开发流程指引
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/chA1-postfcace/">
                                    
                                    结语
                                </a>
                                
                            </li>
                        
                    
                </ul>
            </nav>
            
            
        </div>

        <div class="page">
            <div class="page__header">
                <div class="menu-icon">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                
                <span class="search-icon">🔎</span>
                
            </div>

            <div class="page__content">
                
                <div class="search-container">
                    <input id="search" type="search" placeholder="Search..">
                    <div class="search-results">
                        <div class="search-results__header"></div>
                        <ul class="search-results__items"></ul>
                    </div>
                </div>
                
                <div class="book-content">
                    
    <h1>5.4 闭包函数</h1>
    <!-- ## 5.4\* 闭包函数 -->
<p>自 Vim8，进一步扩展与完善了函数引用的概念，并增加了对闭包与 lambda 表达式的支
持。请用 <code>:version</code> 命令确认编译版本有 <code>+lambda</code> 特性支持。</p>
<h3 id="bi-bao-han-shu-ding-yi">闭包函数定义</h3>
<p>学习 Vim 新功能，在线帮助文档是最佳资料。查阅 Vim8 的 <code>:help :function</code>，可发
现在定义函数时，除了原有的几个属性 <code>range</code> <code>abort</code> <code>dict</code> 外，还多了一个
<code>closure</code> 属性。这就是定义闭包函数的关键字。并给出了一个示例，我们先将其复制到
一个脚本中并执行：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;File: ~/.vim/vimllearn/closure.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Foo</span><span>()
</span><span>    </span><span style="color:#96b5b4;">let</span><span> x = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Bar</span><span>() closure
</span><span>        </span><span style="color:#96b5b4;">let</span><span> x += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">return</span><span> x
</span><span>    </span><span style="color:#b48ead;">endfunction
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">funcref</span><span>(</span><span style="color:#a3be8c;">&#39;Bar&#39;</span><span>)
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>这里有几点需要说明：</p>
<ul>
<li>函数可以嵌套了，在一个函数体内可以再定义另一个函数。</li>
<li>内层函数 <code>Bar()</code> 指定了 <code>closure</code> 属性，就是将其定义为闭包函数。</li>
<li>在内层闭包函数 <code>Bar()</code> 中，可以使用外层环境函数 <code>Foo()</code> 的局部变量 <code>x</code>。</li>
<li>外层函数返回的是内层函数的引用。</li>
<li>当 <code>Foo()</code> 函数返回后，在 <code>Bar()</code> 内仍然可正常使用局部变量 <code>x</code>。</li>
</ul>
<p>现在来使用这个闭包，可在命令行中直接输入以下语句试运行：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let</span><span> Fn = </span><span style="color:#8fa1b3;">Foo</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span></code></pre>
<p>可见，在每次调用 <code>Fn()</code>，也就是调用 <code>Bar()</code> 时，它会返回递增的自然数，在两次调
用之间，会记住变量 <code>x</code> 的值。对比普通函数，当其返回后，其部分变量就离开作用域
不再可见，每次调用必须重新创建与初始化局部变量。而 <code>Bar()</code> 函数能记住 <code>x</code> 变量
的状态，就是由于 <code>closure</code> 关键字的作用。</p>
<p>除些之外，<code>Bar()</code> 就与普通函数一样了。特别地，它的函数全名就是 <code>'Bar'</code>，即它也
是个全局函数，也可以直接在命令行调用。如下语句依然正常地输出递增自然数：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Bar</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Bar</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span></code></pre>
<p>另外必须指出的是，在 <code>Foo()</code> 函数内创建 <code>Bar()</code> 引用时，用的是 <code>funcref()</code> 函
数，而不是 <code>function()</code> 函数。<code>funcref()</code> 也是 Vim8 才引入的内置函数，它与之前
的 <code>function()</code> 函数功能一样，也就是创建一个函数引用。只有一个差别，
<code>function()</code> 只简单地按函数名寻找它所“引用”的函数，而 <code>funcref()</code> 是按真正的函
数引用寻找目标函数。这其中的差别只在原函数被重定义了才能体现。</p>
<p>例如，我们再用 <code>function()</code> 创建一个类似的闭包函数引用，为示区别每次递增 2。将
以下代码附加在原脚本之后，再次加载运行。</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; &gt;&gt;File: ~/.vim/vimllearn/closure.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Goo</span><span>()
</span><span>    </span><span style="color:#96b5b4;">let</span><span> x = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Bar</span><span>() closure
</span><span>        </span><span style="color:#96b5b4;">let</span><span> x += </span><span style="color:#d08770;">2
</span><span>        </span><span style="color:#b48ead;">return</span><span> x
</span><span>    </span><span style="color:#b48ead;">endfunction
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;Bar&#39;</span><span>)
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">let</span><span> Gn = </span><span style="color:#8fa1b3;">Goo</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Bar</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span></code></pre>
<p>初步看来，<code>Goo()</code> 函数能与 <code>Foo()</code> 完全一样地使用，获取一个闭包引用，依次调用
，并且可与所引函数 <code>Bar()</code> 交替调用，也能保持正确的状态。</p>
<p>但要注意，在 <code>Goo()</code> 函数内定义的闭包函数也是 <code>Bar()</code> 。所以在每次调用 <code>Goo()</code>
或 <code>Foo()</code> 都会重新定义全局函数 <code>Bar()</code>。如果用 <code>function()</code> 获取 <code>Bar()</code> 的引
用，它就是使用最新的函数定义。如果用 <code>funcref()</code> 获取 <code>Bar()</code> 的引用，它就一直
使用当时的函数定义。</p>
<p>例如，我们直接在外面再次重定义一下 <code>Bar()</code> 函数：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Bar</span><span>() 
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#a3be8c;">&#39;Bar() redefined&#39;
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Bar</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span></code></pre>
<p>运行结果表明，<code>Fn()</code> 能继续递增数值，但 <code>Gn()</code> 却调用了重新定义的函数，失去了
递增的原意。</p>
<p>所以，为了保证闭包函数的稳定性，务必使用新函数 <code>funcref()</code> ，而不要用旧函数
<code>function()</code>。当然，<code>function()</code> 函数除了为保证兼容性外，应该也还有其适合场景
。</p>
<p>另外，非常不建议直接调用闭包函数，应该坚持只通过函数引用变量来调用闭包。但是，
目前的 VimL 语法，似乎没法完全阻止直接调用闭包。因为 <code>:function</code> 定义的是函数
，而非变量，不能为函数名添加 <code>l:</code> 前缀来限制其作用域。可以加 <code>s:</code> 定义为脚本范
围的函数，但它仍然可以从外部调用（相对于创建闭包的 <code>Foo()</code> 环境而言）。一个建
议是为闭合函数名添加一些特殊后缀，给直接书写调用增加一些麻烦。</p>
<h3 id="bi-bao-bian-liang-li-jie">闭包变量理解</h3>
<p>闭包函数的关键是闭包变量，也就是闭包函数内所用到的外部局部变量。</p>
<p>其实，在一个函数内使用外部变量是很平凡的。比如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:x</span><span> = </span><span style="color:#d08770;">0
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:Bar</span><span>() </span><span style="color:#65737e;">&quot; closure
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:x</span><span> += </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">s:x
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>这里只用以前的函数知识定义了一个 <code>s:Bar()</code> 脚本函数，它用到脚本局部变量 <code>s:x</code>
。每次调用 <code>s:Bar()</code> 时，也能递增这个变量。似乎也能达到之前闭包函数的作用，然
而这只是幻觉。因为 <code>s:x</code> 不是专属于 <code>s:Bar()</code> 函数的，即使也限制了脚本作用域，
也能被脚本中其他函数或语句修改。</p>
<p>而之前闭包函数 <code>Bar()</code> 的变量 <code>x</code> ，原是 <code>Foo()</code> 函数内创建的局部变量。当
<code>Foo()</code> 函数返回后，这个局部变量理论上要释放的，也就无从其他地方再次访问，只能
通过 <code>Bar()</code> 这个即时定义的闭包函数才能访问。</p>
<p>所以，闭包变量既是外部变量，更重要的是外部的局部变量。这才能保证闭包函数对于闭
包变量的专属访问。也因为这个原由，在顶层（脚本或命令）定义的函数不能指定闭包属
性。如上定义 <code>s:Bar()</code> 函数时若加上 <code>closure</code> 将会直接失败。而一般只能嵌套在另
一个函数中定义闭包函数，这个外层函数有的也叫工厂函数。工厂函数为闭包提供一个临
时的局部环境，闭包变量先是在工厂函数中创建并初始化，而在闭包函数里面则是自动检
测的，凡用到的外部局部变量都会转为闭包函数。当然了，在工厂函数或闭包函数内都可
以有其他各自的普通局部变量。</p>
<p>在工厂函数内创建闭包函数时，闭包变量就成为了闭包函数的一个内部属性。每次调用工
厂函数时，会创建闭包函数的不同副本，也就会有相应闭包变量的不同副本。也就是说，
每次创建的闭包函数会维护各自的状态，互不影响。</p>
<p>为说明这个问明，再举个例子。比如把上面实现的递增 1 与递增 2 的两个闭包放在一个
工厂函数内创建，借用列表同时返回两个闭包：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">FGoo</span><span>(base)
</span><span>    </span><span style="color:#96b5b4;">let</span><span> x = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>base
</span><span>    </span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Bar1_cf</span><span>() closure
</span><span>        </span><span style="color:#96b5b4;">let</span><span> x += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">return</span><span> x
</span><span>    </span><span style="color:#b48ead;">endfunction
</span><span>    </span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Bar2_cf</span><span>() closure
</span><span>        </span><span style="color:#96b5b4;">let</span><span> x += </span><span style="color:#d08770;">2
</span><span>        </span><span style="color:#b48ead;">return</span><span> x
</span><span>    </span><span style="color:#b48ead;">endfunction
</span><span>    </span><span style="color:#b48ead;">return</span><span> [</span><span style="color:#8fa1b3;">funcref</span><span>(</span><span style="color:#a3be8c;">&#39;Bar1_cf&#39;</span><span>), </span><span style="color:#8fa1b3;">funcref</span><span>(</span><span style="color:#a3be8c;">&#39;Bar2_cf&#39;</span><span>)]
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">echo </span><span style="color:#a3be8c;">&#39;FGoo(base)&#39;
</span><span style="color:#96b5b4;">let</span><span> [Fn, X_] = </span><span style="color:#8fa1b3;">FGoo</span><span>(</span><span style="color:#d08770;">10</span><span>)
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">let</span><span> [X_, Gn] = </span><span style="color:#8fa1b3;">FGoo</span><span>(</span><span style="color:#d08770;">20</span><span>)
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Gn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span><span style="color:#96b5b4;">echo </span><span style="color:#8fa1b3;">Fn</span><span>()
</span></code></pre>
<p>另一个改动是给工厂函数传个参数，让其成为闭包递增的初值。在调用工厂函数时，也利
用列表解包的语法，同时获得返回的两个闭包函数（引用）。第一次 <code>let [Fn, X_] = FGoo(10)</code> 用 <code>10</code> 作为初值，且只关心第一个闭包 <code>Fn</code> ，第二个 <code>X_</code> 只作为占位变
量弃而不用。在执行 <code>Fn()</code> 数据后，第二次调用 <code>let [X_, Gn] = FGoo(20)</code> 传入另
一个初值，且只取第二个闭包 <code>Gn</code>。然后可以发现这两个闭包能并行不悖地执行。这说
明闭包变量 <code>x</code> 虽然是在 <code>FGoo</code> 中创建，却不随之保存，而是保存在各个被创建的闭
包函数中。</p>
<h3 id="pian-bao-yin-yong">偏包引用</h3>
<p>自 Vim8 ，不仅为创建函数引用增加了一个全新的内置函数，而且还为 <code>function()</code> 与
<code>funcref()</code> 升级了功能。除了提供函数名外，还可以提供一个可选的列表参数，作为所
引用函数的部分的参数。如此创建的函数引用叫做 <code>partial</code> ，这里将之称为偏包。</p>
<p>请看以下示例：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Full</span><span>(x, y, z)
</span><span>    </span><span style="color:#96b5b4;">echo </span><span style="color:#a3be8c;">&#39;Full called:&#39; </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>x </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>y </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>z
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">let</span><span> Part = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;Full&#39;</span><span>, [</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>])
</span><span>call </span><span style="color:#8fa1b3;">Part</span><span>(</span><span style="color:#d08770;">5</span><span>)
</span></code></pre>
<p>首先定义了一个“全”函数 <code>Full()</code> ，它接收三个参数，不妨把它认为是三维空间上的坐
标点。假设有种需求，平面坐标已经是固定的了，只是还要经常改变高坐标。这时就可用
<code>function()</code> （或 <code>funcref()</code>）创建一个偏包，将代表固定平面坐标的前两个参数放
在一个列表变量中，传给 <code>function()</code> 的两个参数。然后调用偏包时，就不必再提供那已
固定的参数，只要传入剩余参数即可。如上调用 <code>Part(5)</code> 就相当于调用 <code>Full(3, 4, 5)</code> 。</p>
<p><code>function()</code> 的第一参数，不仅可以是函数名，也可以是其他函数引用。于是偏包的定
义可以链式传递（有的叫嵌套）。例如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let</span><span> Part</span><span style="color:#d08770;">1</span><span> = </span><span style="color:#8fa1b3;">function</span><span>(</span><span style="color:#a3be8c;">&#39;Full&#39;</span><span>, [</span><span style="color:#d08770;">3</span><span>])
</span><span style="color:#96b5b4;">let</span><span> Part</span><span style="color:#d08770;">2</span><span> = </span><span style="color:#8fa1b3;">function</span><span>(Part</span><span style="color:#d08770;">1</span><span>, [</span><span style="color:#d08770;">4</span><span>])
</span><span>call </span><span style="color:#8fa1b3;">Part2</span><span>(</span><span style="color:#d08770;">5</span><span>) |</span><span style="color:#65737e;">&quot; =&gt; call Full(3, 4, 5)
</span></code></pre>
<p>须要注意的是，在创建偏包时，即使只要固定一个参数，也必须写在 <code>[]</code> 中，作为只有
一个元素的列表传入。</p>
<p>为什么这叫偏包，因为偏包本质上是个自动创建的闭包。例如以上为 <code>Full()</code> 创建的偏
包，相当于如下闭包：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">FullPartial</span><span>()
</span><span>    </span><span style="color:#96b5b4;">let</span><span> x = </span><span style="color:#d08770;">3
</span><span>    </span><span style="color:#96b5b4;">let</span><span> y = </span><span style="color:#d08770;">4
</span><span>    </span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Part_cf</span><span>(z) closure
</span><span>        </span><span style="color:#96b5b4;">let</span><span> z = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>z
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">Full</span><span>(x, y, z)
</span><span>    </span><span style="color:#b48ead;">endfunction
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">funcref</span><span>(</span><span style="color:#a3be8c;">&#39;Part_cf&#39;</span><span>)
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">let</span><span> Part = </span><span style="color:#8fa1b3;">FullPartial</span><span>()
</span><span>call </span><span style="color:#8fa1b3;">Part</span><span>(</span><span style="color:#d08770;">5</span><span>)
</span></code></pre>
<p>至于用 <code>function()</code> 创建通用偏包的功能，可用如下闭包模拟：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">FuncPartial</span><span>(</span><span style="color:#b48ead;">fun</span><span>, arg)
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:arg_closure</span><span> = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>arg
</span><span>    </span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Part_cf</span><span>(</span><span style="color:#b48ead;">...</span><span>) closure
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:arg_passing</span><span> = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:arg_all</span><span> = </span><span style="color:#bf616a;">l:arg_closure</span><span> + </span><span style="color:#bf616a;">l:arg_passing
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:fun</span><span>, </span><span style="color:#bf616a;">l:arg_all</span><span>)
</span><span>    </span><span style="color:#b48ead;">endfunction
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">funcref</span><span>(</span><span style="color:#a3be8c;">&#39;Part_cf&#39;</span><span>)
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">let</span><span> Part = </span><span style="color:#8fa1b3;">FuncPartial</span><span>(</span><span style="color:#a3be8c;">&#39;Full&#39;</span><span>, [</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>])
</span><span>call </span><span style="color:#8fa1b3;">Part</span><span>(</span><span style="color:#d08770;">5</span><span>)
</span></code></pre>
<p>以上的语句 <code>let l:arg_all = l:arg_closure + a:000</code> 表明了在调用偏包时，传入的
参数是串接在原来保存在闭包中的参数表列之后的。其实，那三条 <code>let</code> 语句创建的中
间变量是可以取消的，只须用 <code>return call(a:fun, a:arg + a:000)</code> 即可。其中
<code>a:fun</code> 与 <code>a:arg</code> 变量来源于外部工厂函数 <code>FuncPartial()</code> 的参数，将成为闭包变
量，而 <code>a:000</code> 则是在调用闭包函数时传入的参数。</p>
<p>这个 <code>FuncPartial()</code> 只为说明偏包与闭包之间的关系，请勿实际使用。另请注意这两
概念的差别，闭包是函数，偏包是引用，偏包是对某个自动创建的闭包的引用。</p>
<p>创建函数引用尤其是偏包引用的 <code>function()</code> 与 <code>funcref()</code> 函数，不仅可以接收额
外的列表参数，还可接收额外的字典参数。这与 <code>call()</code> 函数的参数意义是一样的。当
需要创建引用的函数有 <code>dict</code> 属性时，传给 <code>function()</code> 的字典参数就将传给目标函
数的 <code>self</code> ，实际上也将该字典升格为闭包变量。之后再调用所创建的偏包引用时，就
不必再指定用哪个字典当作 <code>self</code> 了。</p>
<p>不过 <code>function()</code> 与 <code>call()</code> 的参数用法也有两个不同：</p>
<ul>
<li><code>call()</code> 至少要两个参数，即使目标函数不用参数，也要传 <code>[]</code>。<code>function()</code> 默
认只要一个参数即可。</li>
<li><code>function()</code> 可以直接传字典变量当作第二参数，不必限定第二参数必须用列表，不
必用 <code>[]</code> 空列表作占位参数。当然也可以同时传入列表与字典参数，此时应按习惯不
要改变参数位置。</li>
</ul>
<h3 id="lambda-biao-da-shi">lambda 表达式</h3>
<p>lambda 表达式用于创建简短的匿名函数，其语法结构如：<code>let Fnr = {args -&gt; expr}</code>
。几个要点：</p>
<ul>
<li>整个 lambda 表达式放在一对大括号 <code>{}</code> 中，其间用箭头 <code>-&gt;</code> 分成两部分。</li>
<li>箭头之前的部分是参数，类似函数参数列表，多个参数由逗号分隔，也可以无参数。无
参数时箭头也不可以缺省，如 <code>{-&gt; expr}</code> 形式。</li>
<li>箭头之后是一个表达式。该表达式的值就是以后调用该 lambda 时的结果。这有点像函
数体，但函数体是由多个 ex 命令语句构成。lambda 的“函数体” 只能是一个表达式。</li>
<li><code>expr</code> 部分在使用 <code>args</code> 的参数时，不要加 <code>a:</code> 参数作用域前缀。</li>
<li>在 <code>expr</code> 部分中还可以使用整个 lambda 表达所处作用域内的其他变量，如此则相当
于创建了一个闭包。</li>
<li>一般需要将 lambda 表达式赋值给一个函数引用变量，如此才能通过该引用调用
lambda 。也就是说 lambda 表达式自身的值类型是 <code>v:t_func</code>。</li>
</ul>
<p>举个例子，假设有如下定义的函数：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">Distance</span><span>(point) abort
</span><span>    </span><span style="color:#96b5b4;">let</span><span> x = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>point[</span><span style="color:#d08770;">0</span><span>]
</span><span>    </span><span style="color:#96b5b4;">let</span><span> y = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>point[</span><span style="color:#d08770;">1</span><span>]
</span><span>    </span><span style="color:#b48ead;">return</span><span> x</span><span style="color:#b48ead;">*</span><span>x + y</span><span style="color:#b48ead;">*</span><span>y
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>这里假设用只含两个元素的列表来表示坐标上的点，该函数的功能是计算坐标点的平方和
，这可作为距离原点的度量。几何上的距离定义其实是平方和再开根号，不过开根号的浮
点运算效率低，尤其是相对整数坐标来说。所以在满足程序逻辑的情况下，可以先不开这
个根号，比如只在最后需要显示在 UI 上才开这个根号。</p>
<p>然而无关背景，这个函数或许很重要，但实现很简单，实际上也可用 lambda 来代替：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let</span><span> Distance = {pt -&gt; pt[</span><span style="color:#d08770;">0</span><span>] </span><span style="color:#b48ead;">*</span><span> pt[</span><span style="color:#d08770;">0</span><span>] + pt[</span><span style="color:#d08770;">1</span><span>] </span><span style="color:#b48ead;">*</span><span> pt[</span><span style="color:#d08770;">1</span><span>]}
</span></code></pre>
<p>当然了，这两段代码不能同时存在，因为函数引用的变量名，不能与函数名重名。分别执
行这两段，测试 <code>:echo Distance([3,4])</code> 能输出 <code>25</code> 。</p>
<p>前面说过，闭包函数不能在脚本（或命令行）顶层定义，但 lambda 表达式可以。因为
lambda 表达式其实是相当于创建闭包的外层工厂函数（及其调用），那当然是可以写在
顶层了。不过就这个 <code>Distance</code> 实例，并未用到外部变量，可不必纠结是否闭包。</p>
<p>然后，我们利用这个函数写一个具体功能，比如计算一个三角形的最大边长。输入参数是
三个点坐标，输出最大边长（的平方）：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">MaxDistance</span><span>(A, B, C) abort
</span><span>    </span><span style="color:#96b5b4;">let</span><span> [A, B, C] = [</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>A, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>B, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>C]
</span><span>    </span><span style="color:#96b5b4;">let</span><span> e</span><span style="color:#d08770;">1</span><span> = [A[</span><span style="color:#d08770;">0</span><span>] - B[</span><span style="color:#d08770;">0</span><span>], A[</span><span style="color:#d08770;">1</span><span>] - B[</span><span style="color:#d08770;">1</span><span>]]
</span><span>    </span><span style="color:#96b5b4;">let</span><span> e</span><span style="color:#d08770;">2</span><span> = [A[</span><span style="color:#d08770;">0</span><span>] - C[</span><span style="color:#d08770;">0</span><span>], A[</span><span style="color:#d08770;">1</span><span>] - C[</span><span style="color:#d08770;">1</span><span>]]
</span><span>    </span><span style="color:#96b5b4;">let</span><span> e</span><span style="color:#d08770;">3</span><span> = [B[</span><span style="color:#d08770;">0</span><span>] - C[</span><span style="color:#d08770;">0</span><span>], B[</span><span style="color:#d08770;">1</span><span>] - C[</span><span style="color:#d08770;">1</span><span>]]
</span><span>    </span><span style="color:#96b5b4;">let</span><span> d</span><span style="color:#d08770;">1</span><span> = </span><span style="color:#8fa1b3;">Distance</span><span>(e</span><span style="color:#d08770;">1</span><span>)
</span><span>    </span><span style="color:#96b5b4;">let</span><span> d</span><span style="color:#d08770;">2</span><span> = </span><span style="color:#8fa1b3;">Distance</span><span>(e</span><span style="color:#d08770;">2</span><span>)
</span><span>    </span><span style="color:#96b5b4;">let</span><span> d</span><span style="color:#d08770;">3</span><span> = </span><span style="color:#8fa1b3;">Distance</span><span>(e</span><span style="color:#d08770;">3</span><span>)
</span><span>    </span><span style="color:#b48ead;">if</span><span> d</span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">&gt;=</span><span> d</span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">&amp;&amp;</span><span> d</span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">&gt;=</span><span> d</span><span style="color:#d08770;">3
</span><span>        </span><span style="color:#b48ead;">return</span><span> d</span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">elseif</span><span> d</span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">&gt;=</span><span> d</span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">&amp;&amp;</span><span> d</span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">&gt;=</span><span> d</span><span style="color:#d08770;">3
</span><span>        </span><span style="color:#b48ead;">return</span><span> d</span><span style="color:#d08770;">2
</span><span>    </span><span style="color:#b48ead;">else
</span><span>        </span><span style="color:#b48ead;">return</span><span> d</span><span style="color:#d08770;">3
</span><span>    </span><span style="color:#b48ead;">endif
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>这里，直接用单字母表示参数了，似乎有违程序变量名的取名规则。不过这也要看具体场
景，因为这是解决数学问题的，直接用数学上习惯的符号取名，其实也是简洁又不失可读
性的。该函数先从顶点坐标计算边向量，再对边向量调用 <code>Distance()</code> 计算距离，返回
其中的最大值。</p>
<p>如果 <code>Distance</code> 是上面定义的函数版本，这个 <code>MaxDistance()</code> 直接可用。比如在命
令行中试行：<code>:echo MaxDistance([2,8], [4,4], [5,10])</code> 将输出 <code>37</code> 。</p>
<p>但如果是用 lambda 表达式版本，将 <code>let Distance = ...</code> 写在全局作用域中，那么在
调用 <code>MaxDistance()</code> 时再调用 <code>Distance()</code> 就会失败，指出函数未定义的错误。把
这个 lambda 表达式写在 <code>MaxDistance()</code> 开头，剩余代码才能正常工作。</p>
<p>不过这个困惑与 lambda 无关，只是作用域规则。解析 <code>let d1=Distance(e1)</code> 时，如
果 <code>Distance</code> 不是一个函数名，就会尝试函数引用。然而在函数内的变量，缺省前缀是
<code>l:</code> ，所以它找不到在外部定义的 <code>g:Distance</code>。基于这个原因，个人非常建议在函数
内部也习惯为局部变量加上 <code>l:</code> 前缀，这样就能使函数引用变量名与函数名从文本上很
好地区分，避免迷惑性出错。</p>
<p>同时，这也说明了 lambda 的习惯用法，一般是在需要用的时候临时定义，而不是像常规
函数那样预先定义。</p>
<p>最后提一下，lambda 作为匿名函数，vim 对其表示法是 <code>&lt;lambda&gt;123</code> ，与上一章介绍
的字典匿名函数一样，只是在编号前再加 <code>&lt;lambda&gt;</code> 前缀，同时这两套编号相互独立。</p>
<h3 id="xiao-jie">小结</h3>
<p>偏包与 lambda 表达式，本质上都是闭包，而闭包也一般只以其函数引用的形式使用。
Vim8 引入这些编程概念的一个原因，是为了方便在局部环境中创建回调函数，与异步、
定时器等特性良好协作。</p>


                </div>
            </div>

            <div class="prev-link">
                
    
        
        
        <a class="previous" href="https://lymslive.github.io/vimllearn/ch05-viml-function/"><</a>
    

            </div>

            <div class="next-link">
                
    
        <a class="next" href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn5-autoload-function/">></a>
    

            </div>
        </div>

        
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/elasticlunr.min.js"></script>
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/search_index.en.js"></script>
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/book.js"></script>
        
    </body>

</html>

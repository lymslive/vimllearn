<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      
    

      <title></title>

      
      

      <!-- CSS -->
      
      <link rel="stylesheet" href="https://lymslive.github.io/vimllearn/book.css">
      

      
      
    </head>

    <body>
        <div class="menu">
            
            
            <nav role="navigation">
                <ul>
                    
                        
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch00-prefcace/">
                                    
                                    前言
                                </a>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/">
                                    
                                    第一章 VimL 语言主要特点
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn1-hello-world/">
                                                    
                                                    1.1 Hello World 的四种写法
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn2-from-ex-command/">
                                                    
                                                    1.2 同源 ex 命令行
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn3-week-type-strong-scope/">
                                                    
                                                    1.3 弱类型强作用域
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn4-autoload-schema/">
                                                    
                                                    1.4 自动加载脚本机制
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/">
                                    
                                    第二章 VimL 语言基本语法
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn1-variable-type/">
                                                    
                                                    2.1 变量与类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn2-comapare-condition/">
                                                    
                                                    2.2 选择与比较
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn3-loop-iterate/">
                                                    
                                                    2.3 循环与迭代
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn4-function-call/">
                                                    
                                                    2.4 函数定义与使用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn5-exception-error/">
                                                    
                                                    2.5 异常处理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/">
                                    
                                    第三章 Vim 常用命令
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn1-option-set/">
                                                    
                                                    3.1 选项设置
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn2-key-remap/">
                                                    
                                                    3.2 快捷键重映射
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn3-custom-command/">
                                                    
                                                    3.3 自定义命令
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn4-execute-normal/">
                                                    
                                                    3.4 execute 与 normal
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn5-autocmd-event/">
                                                    
                                                    3.5 自动命令与事件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn6-debug-command/">
                                                    
                                                    3.6 调试命令
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/">
                                    
                                    第四章 VimL 数据结构进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn1-list-string/">
                                                    
                                                    4.1 再谈列表与字符串
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn2-dictionary/">
                                                    
                                                    4.2 通用的字典结构
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn3-nest-compose/">
                                                    
                                                    4.3 嵌套组合与扩展
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn4-regex-apply/">
                                                    
                                                    4.4 正则表达式
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/">
                                    
                                    第五章 VimL 函数进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn1-variable-argument/">
                                                    
                                                    5.1 可变参数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn2-function-refer/">
                                                    
                                                    5.2 函数引用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn3-dict-function/">
                                                    
                                                    5.3 字典函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn4-closure-lambda/">
                                                    
                                                    5.4 闭包函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn5-autoload-function/">
                                                    
                                                    5.5 自动函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/">
                                    
                                    第六章 VimL 内建函数使用
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn1-operate-datatype/">
                                                    
                                                    6.1 操作数据类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn2-operate-edit-object/">
                                                    
                                                    6.2 操作编辑对象
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn3-operate-filesystem/">
                                                    
                                                    6.3 操作系统文件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn4-other-utility/">
                                                    
                                                    6.4 其他实用函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/">
                                    
                                    第七章 VimL 面向对象编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn1-object-intro/">
                                                    
                                                    7.1 面向对象的简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn2-dict-object/">
                                                    
                                                    7.2 字典即对象 
                                                </a>
                                            </li>
                                        
                                            <li class="active">
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn3-object-organize/">
                                                    
                                                    7.3 自定义类的组织管理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/">
                                    
                                    第八章 VimL 异步编程特性
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn1-asynchronous-intro/">
                                                    
                                                    8.1 异步工作简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn2-asynchronous-job/">
                                                    
                                                    8.2 使用异步任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn3-channle-job/">
                                                    
                                                    8.3 使用通道控制任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn4-internal-terminal/">
                                                    
                                                    8.4 使用配置内置终端
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/">
                                    
                                    第九章 VimL 混合编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn1-extern-filter/">
                                                    
                                                    9.1 用外部语言写过滤器
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn2-extern-interface/">
                                                    
                                                    9.2 外部语言接口编程
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn3-perl-interface/">
                                                    
                                                    9.3 Perl 语言接口开发
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/">
                                    
                                    第十章 Vim 插件管理与开发
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn1-plugin-directory/">
                                                    
                                                    10.1 典型插件的目录规范
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn2-plugin-manager/">
                                                    
                                                    10.2 插件管理器插件介绍
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn3-plugin-devflow/">
                                                    
                                                    10.3 插件开发流程指引
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/chA1-postfcace/">
                                    
                                    结语
                                </a>
                                
                            </li>
                        
                    
                </ul>
            </nav>
            
            
        </div>

        <div class="page">
            <div class="page__header">
                <div class="menu-icon">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                
                <span class="search-icon">🔎</span>
                
            </div>

            <div class="page__content">
                
                <div class="search-container">
                    <input id="search" type="search" placeholder="Search..">
                    <div class="search-results">
                        <div class="search-results__header"></div>
                        <ul class="search-results__items"></ul>
                    </div>
                </div>
                
                <div class="book-content">
                    
    <h1>7.3 自定义类的组织管理</h1>
    <!-- ## 7.3 自定义类的组织管理 -->
<p>在上一节已经讲叙了如何利用 VimL 语法实现面向对象编程的基本原理，本节进一步讨论
在实践中如何更好地使用 VimL 面向对象编程。关键是如何定义类与使用类，如何管理与
组织类代码使之更整洁。因为从某种意义讲，面向对象并不是什么新的编程技术，而是抽
象思考问题的哲学，以及代码管理的方法论。</p>
<p>笔者在 github 托管了一个有关 VimL 面向对象编程的项目
<a href="https://github.com/lymslive/vimloo">vimloo</a>，可作为一个实现范例。本节就介绍这
个 vimloo 项目的基本思路，不过该项目代码有可能继续更新维护与优化，故本节教程所
采用的示例代码为求简单，不尽与实际项目相同。</p>
<h3 id="mei-ge-lei-du-li-yu-yi-ge-zi-dong-jia-zai-wen-jian">每个类独立于一个自动加载文件</h3>
<p>在上一节的示例代码中，我们定义了一个名为 <code>class</code> 的类。因为彼时只关注实现原理
，并未指定相关代码应保存何处。你可以放在任一个脚本中，甚至也可以粘贴入命令行，
也能起到演示之用。</p>
<p>如果你想用 VimL 实现一个规划不太大的（插件）功能，又想用到字典的对象特征，想在
单文件中实现全部（或大部分）功能，那么也着实可以就像是上节的示例那样，在单文件
中定义类然后使用类。但是，既然想到要用面向对象的设计，那么一般地每个类都应该是
相对独立完整的功能单元。这时，将类的定义代码提取出来放在独立的文件中就更合适了
，这也可以达到隐藏类实现细节的目的，在其他需要使用对象的地方，只需创建相应类的
对象，调用该类对象所支持的方法即可。</p>
<p>简言之，要区分类的实现者与使用者（尽管很多时候这是同一个程序员的工作）。在
VimL 中，如果要将类的定义代码单独存于一个文件中，最适合的地方应该就是
<code>autoload/</code> 子目录下的自动加载文件了。因为它可以让用户从任意地方调用，并且只在
真正需要用到时才加载类定义代码。</p>
<p>于是，将上节的 <code>class</code> 类定义稍作修改，保存于某个 <code>&amp;rtp</code> （如 <code>~/.vim</code>）的
<code>autoload/class.vim</code> 文件中：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span> = {}
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>name = </span><span style="color:#a3be8c;">&#39;class&#39;
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>version = </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">string</span><span>() abort dict
</span><span>    </span><span style="color:#b48ead;">return</span><span> self</span><span style="color:#b48ead;">.</span><span>name
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">number</span><span>() abort dict
</span><span>    </span><span style="color:#b48ead;">return</span><span> self</span><span style="color:#b48ead;">.</span><span>version
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">disp</span><span>() abort dict
</span><span>    </span><span style="color:#96b5b4;">echo</span><span> self</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">string</span><span>() </span><span style="color:#b48ead;">. </span><span style="color:#a3be8c;">&#39;:&#39; </span><span style="color:#b48ead;">.</span><span> self</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">number</span><span>()
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>主要是将定义的类（字典）名字改为 <code>s:class</code>，使之成为局部于脚本的变量。这样在不
同文件中定义的不同类也都能用相同的字面名字 <code>s:class</code> 而互不冲突。该变量名的选
用是任意的，在不同类文件中选用不同变量名也可以，只要在随后定义类的属性与方法也
都用相应的字典变量名即可。但这里的建议是，为求风格统一，每个类文件定义的类字典
变量都取名为 <code>s:class</code>。</p>
<p>在这个 <code>class.vim</code> 中定义的类没打算做什么实际工作，因此只（貌似随意地）定义了
两个属性与几个方法。当然，你也可以将 <code>string()</code> 与 <code>number()</code> 方法想象为类型转
换方法，用于在必要时如何将一个对象转为字符串或数字的表示法。</p>
<h3 id="shi-yong-zi-dong-jia-zai-han-shu-chu-li-lei-fang-fa">使用自动加载函数处理类方法</h3>
<p>现在 <code>class.vim</code> 文件中定义的 <code>s:class</code> 类只能在该文件中访问，这显然是不够的。
为了达到分离类定义与类使用的设计原意，我们还得在 <code>class.vim</code> 提供一些公有接口
让外界使用类。自动加载函数就是一个很好的选择，因为它既是全局函数，又通过 <code>#</code>
前缀限定了“伪作用域”。例如，添加以下函数：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#class</span><span>() abort
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">s:class
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#new</span><span>() abort
</span><span>   </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#8fa1b3;">copy</span><span>(</span><span style="color:#bf616a;">s:class</span><span>)
</span><span>   </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:obj
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#isobject</span><span>(that) abort
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>that</span><span style="color:#b48ead;">.</span><span>name </span><span style="color:#b48ead;">==# </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>name
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>先看 <code>class#class()</code> 这个略有奇怪的函数命名。<code>class#</code> 前缀部分是对应
<code>class.vim</code> 文件名路径的，<code>class()</code> 可认为是该函数的基础名字。它的作用很简单（
也很关键），就是返回当前文件定义的类 <code>s:class</code>，使外界有个途径能使用这个类。这
就是个取值函数，也可命名为 <code>getclass()</code> 或许可更易理解。</p>
<p><code>class#new()</code> 函数就是用于创建一个新对象。我们使用一个类时，第一步往往就是新建
对象，这就只要调用 <code>class#new()</code> 就可以了。如果之前尚未加载类 <code>class</code> 的定义，
就会按自动加载机制加载 <code>class.vim</code>，也就完成其内 <code>s:class</code> 的定义。普通用户一
般情况下根本用不到 <code>class#class()</code> 获取 <code>s:class</code> 的定义，除非想动态修改类定义
（慎重）。如果真的想向用户完全隐藏类定义，不提供 <code>class#class()</code> 函数即可，只
提供 <code>class#new()</code> 让用户能创建对象好了。</p>
<p>所以才将创建对象的函数定义为 <code>class#new()</code> 而非像上节那样的方法 <code>s:class.new()</code>，
让用户直接上手创建对象，而不必关心类定义是否已加载。其次也是由于 VimL 只能按复
制式创建对象，如果把 <code>s:class.new()</code> 方法也复制到对象中，是很没必要的，甚至还
可能被误用。</p>
<p>至于 <code>class#isobject()</code> ，用于判断一个对象是否属于本文件所定义的类。在某些应用
中，先作类型判断是有意义的甚至是必要的。这里暂且先用类的 <code>name</code> 属性来标记一个
类，因此为了保证类名的唯一性，<code>name</code> 属性的取值也按自动加载函数的规则取文件名
路径（即如 <code>class#class()</code> 函数的前缀部分）。如果在某个深层子目录中定义的类，
如 <code>autoload/topic/subject.vim</code> 文件内定义的 <code>s:class</code> 类名属性就应该是
<code>topic#subject</code>。当然了，另有一个建议，由于 VimL 的大多数脚本都未必是类定义文
件，为了更明确表示它是个类文件，可将更多实用的类都统一放在 <code>class/</code> 子目录下，
如 <code>autoload/class/topic/subject.vim</code>，如果其类名就是 <code>class#topic#subject</code>。
严格地讲，<code>class#isobject()</code> 要稳健地执行，还应判断所传入的参数 <code>a:that</code> 是否
字典类型，以及是否有 <code>name</code> 这个属性。</p>
<p>然后，可以根据需要设计更多的函数。这有两种选择，如果是操作对象的方法，应存入
<code>s:class</code> 字典，如 <code>s:class.method()</code>。如果它不适合用作对象的方法属性，而着重
与类型有关，可定义为自动加载函数，如 <code>class#func()</code>。</p>
<h3 id="qu-fen-lei-shu-xing-yu-dui-xiang-shu-xing">区分类属性与对象属性</h3>
<p>从前面的章节讨论中，我们意识到类属性与对象属性可以是两个不同的概念，这是值得优
化的一个方向。尤其是 VimL 中若用简单粗暴的全复制方式创建对象，把那些通用的属性
复制到每个对象中，显然是个浪费。例如上一小节的类名属性 <code>name</code>，尤其是深层目录
的类文件，像 <code>class#topic#subject</code> 这样的字符串已经不短了，每创建一个新对象都
保存这样一个属性值，似乎很不值了。</p>
<p>但另一方面，在类定义字典中保存类名属性也是有意义的，因其关联了文件路径，也可据
此间接调用方式文件内的自动加载函数。所以，最好是能限定类名属性不被复制到新建对
象中。因此为了区分，约定将类属性的命名加两个下划线，如 <code>_name_</code>。这样，某些具
体的对象也可能需要自己的 <code>name</code> 属性，也不致键名冲突。</p>
<p>按这种思路，我们再试写另一个类文件：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subclass.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span> = {}
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>_name_ = </span><span style="color:#a3be8c;">&#39;class#subclass&#39;
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>_version_ = </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#65737e;">&quot; Todo: 其他对象属性预设
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>value = </span><span style="color:#d08770;">0
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#class</span><span>() abort
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">s:class
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#new</span><span>() abort
</span><span>   </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#8fa1b3;">Copy</span><span>(</span><span style="color:#bf616a;">s:class</span><span>) </span><span style="color:#65737e;">&quot; Todo: 另外定制的特殊“复制”函数
</span><span>   </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:obj
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>之前定义在 <code>autoload/class.vim</code> 文件中名为 <code>class</code> 的类，不妨当作整个自定义
VimL 类系统的通用基类。在实际工作中一般不会直接用到 <code>class</code> 类及其实例对象。所
以我们开始设计实际可用的子类，建议将所有实用类归于 <code>class/</code> 子目录下。以上也仅
是个说明示例，故类名简单取为 <code>subclass</code>，按自动加载机制，其全名则是
<code>class#subclass</code> 。</p>
<p>这个类文件的基本框架与之前类似，只不过将原来的类属性改名为 <code>_name_</code> 与
<code>_version_</code> 。属于该类的对象的属性名，不加下划线，比如 <code>value</code>。然后创建对象的
<code>#new()</code> 函数，显然不能直接用 <code>copy()</code> 或 <code>deepcopy()</code> 内置函数了。这个辅助的
特殊复制函数需要另外实现，不过将其命名为 <code>Copy()</code> 或 <code>SpecialCopy()</code> 就显得有
点蠢了。联想到之前的 <code>class#new()</code> 函数，既然一般没必要创建 <code>class</code> 顶层基类的
实例对象，不妨将 <code>class.vim</code> 内定义的函数改为公共基础设施函数。于是修改如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subclass.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#new</span><span>(</span><span style="color:#b48ead;">...</span><span>) abort
</span><span>   </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#8fa1b3;">class#new</span><span>(</span><span style="color:#bf616a;">s:class</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000</span><span>)
</span><span>   </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:obj
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>这里，只是将当前文件定义的类 <code>s:class</code> 与任意参数 <code>a:000</code> 传给 <code>class#new()</code>
基础设施函数，然后也是返回所创建的对象。至于 <code>class#new()</code> 的具体实现，略复杂
，请参考 vimloo 项目的 <code>autoload/class.vim</code>。这里只说明它主要做的几件事：</p>
<p>一是分析 <code>s:class</code> 的键，过滤掉带下划线前后缀的属性名，只把普通属性复制到对象
实例中。如上例的 <code>class#subclass</code> 类，由 <code>#new()</code> 创建出的对象只有 <code>value</code> 属性。</p>
<p>二是给每个新建对象添加唯一一个特殊属性，名为 <code>_class_</code> ，就是对 <code>s:class</code> 的引
用。这样每个对象都能知道自己所属的类了，在有必要时可访问这个类字典获得其他信息
。而且保存类字典的引用，比保存类名字符串在安全性与效率性上都好得多。然后，判断
一个对象是否属于本类的函数也能利用该属性，可大约修改如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subclass.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#isobject</span><span>(that) abort
</span><span style="color:#65737e;">    &quot; is 是操作符，相当于 == 用于比较相同的引用
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">type</span><span>(</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>that) = </span><span style="color:#8fa1b3;">type</span><span>({}) </span><span style="color:#b48ead;">&amp;&amp; </span><span style="color:#8fa1b3;">get</span><span>(</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>that, </span><span style="color:#a3be8c;">&#39;_class_&#39;</span><span>, {}) is </span><span style="color:#bf616a;">s:class
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>其实还有第三个隐藏事件，这只在每个类创建第一个对象时发生。为了避免每次创建对象
都要作第一步的分析过滤 <code>s:class</code> 的键名，<code>class#new()</code> 会在第一次记忆这个结果
，保存在一个特殊键 <code>s:class._object_</code> 中。这是向用户隐藏的第一个实例，用户新建
使用到的实例是直接从这个实例深拷贝的（<code>deepcopy()</code>）。我们可以将其视为这个类的
“长子”，是其他实际干活的小弟们的楷模。</p>
<h3 id="kong-zhi-ji-cheng-yu-duo-ceng-ji-cheng">控制继承与多层继承</h3>
<p>然后讨论 vimloo 项目对继承的实现。首先不要惊讶于命名学上的选用。因为前文已经说
明，继承与实例化一样底层都是通过复制实现的。既然创建新对象是用 <code>#new()</code> 函数，
那么创建新子类就用个相对的单词 <code>#old()</code> 。</p>
<p>假设要从 <code>subclass</code> 继承一个类 <code>subsubclass</code>，类文件保存于 <code>class/subsubclass.vim</code>。
当然你也可保存于 <code>class/subclasss/subsubclass.vim</code> 文件中，只是名字略长。这里
要指出的是，文件系统的目录层次，未必要强求与类的继承链一一对应，那也会有其他麻
烦，仅从文件管理角度看，将相关主题的类文件放在一个目录中就能接受了。</p>
<p>要实现这个继承关系，有两点需要改动。一是在 <code>subsubclass.vim</code> 中创建 <code>s:class</code>
时不再初始化为空字典，而是调用 <code>subclass#old()</code> 返回的字典；二就是要在
<code>subclass.vim</code> 中实现 <code>subclass#old()</code> 函数，描述如何将自己这个类继承（复制）
给子类。代码框架如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subsubclass.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span> = </span><span style="color:#8fa1b3;">subclass#old</span><span>()
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>_name_ = </span><span style="color:#a3be8c;">&#39;class#subsubclass&#39;
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span style="color:#b48ead;">.</span><span>_version_ = </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#65737e;">&quot; Todo: 其他类属性与方法
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subsubclass#new</span><span>(</span><span style="color:#b48ead;">...</span><span>) abort
</span><span>   </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#8fa1b3;">class#new</span><span>(</span><span style="color:#bf616a;">s:class</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000</span><span>)
</span><span>   </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:obj
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subclass.vim
</span><span>
</span><span style="color:#65737e;">&quot; 其他沿用，添加 #old() 方法
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#old</span><span>(</span><span style="color:#b48ead;">...</span><span>) abort
</span><span>   </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:class</span><span> = </span><span style="color:#8fa1b3;">class#old</span><span>(</span><span style="color:#bf616a;">s:class</span><span>)
</span><span>   </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:class
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>可见 <code>subsubclass.vim</code> 的类定义框架与之前的 <code>subclass.vim</code> 很是类似，只有第一
行初始化 <code>s:class</code> 的不同。甚至创建对象的 <code>#new()</code> 方法的写法也完全一样，因为
把复制的细节都提炼到 <code>class#new()</code> 这个通用设施上了。用户可直接上手调用
<code>class#subsubclass#new()</code> 方法创建对象，按 VimL 自动加载机制，<code>subsubclass.vim</code>、
<code>subclass.vim</code> 与 <code>class.vim</code> 这三个脚本文件都会触发加载。</p>
<p>至于继承函数 <code>class#subclass#old()</code> 与实例化函数 <code>class#subclass#old()</code> 也类似
，将复制的细节委托通用的 <code>class#old()</code> 函数处理。它也是分析过滤 <code>s:class</code> 的键
，将必要的键复制给子类，并在子类字典中添加一个特殊键 <code>_mother_</code> 引用自身类字典
。（具体实现代码就不帖了，看 vimloo 项目源码）</p>
<p>如果要让 <code>subclass</code> 继承自 <code>class</code>，也可修改 <code>subclass.vim</code> 中对 <code>s:class</code> 的
创建语句 <code>let s:class = class#old()</code>。因为 <code>class#new()</code> 与 <code>class#old()</code> 函数
接收可变参数，一般将其第一个参数视为类定义字典，即其他类文件中的 <code>s:class</code>，当
然也可以是类名字符串，根据类名可获取其 <code>s:class</code> 字典；如果没有参数时，就用
<code>class.vim</code> 文件本身的 <code>s:class</code> 类字典。不过，由于在 <code>class.vim</code> 的 <code>s:class</code>
在实践中实在乏善可陈，在第二版（<code>_version_ = 2</code>）时，无参调用 <code>class#old()</code> 会
快速返回空字典 <code>{}</code> 。自定义的顶层类没有母类（基类），或 <code>_mother_</code> 属性为空。</p>
<p>因此，vimloo 实现的类体系，可类比“母系社会”来理解。从一个母类中有两种繁衍，“女
儿”是子类，主要用途就是继续繁衍；“儿子”是实例化对象，就是用来实际工作干活的。
子类中通过 <code>_mother_</code> 属性记录母类的联系，实例中是 <code>_class_</code> 属性。由于实际工
作中可能需要许多同质的实例对象，故而还设置了一个隐藏的 <code>_object_</code> 长子监管。这
套机制用于描绘单继承应该足够清晰易懂。</p>
<p>能用单继承解决的问题，尽量避免多重继承。不过 vimloo 也实现了多重继承的支持。每
个类的 <code>_mother_</code> 属性虽然只记录了唯一的母类，但也允许有其他基类，有两种“其他
基类”。一种叫 <code>_master_</code> （意为“师父”），只继承其方法，不继承其数据；另一种叫
<code>_father_</code> （意为“父亲”），只继承其数据，不继承其方法。每个类的 <code>_master_</code> 与
<code>_father_</code> 属性（如果有），都是数组，即可以是多个来自其他类文件定义的 <code>s:class</code>。
只不过这些“其他基类”的属性，都不会直接导入当前文件的 <code>s:class</code> 中，只有当创建
对象实例时（如 <code>s:class._object_</code> 长子），才会分析这些类的键名，将必要的键复制
下来。</p>
<p>也可以通过形象的比喻来理解这个模型。如一位母亲抚育孩子，额外聘请多位老师教孩子
其他技艺，这是可理解的（相当于某些语言的接口方法），不过母亲本身未必要掌握这些
技能，她的目的是孩子们能学会就可以了。当然了，另一方面，也允许多个“父亲”，这思
想有点危险啊，最好避而不用吧。</p>
<h3 id="gou-zao-han-shu-yu-xi-gou-han-shu">构造函数与析构函数</h3>
<p>重新审视一下创建对象的 <code>#new()</code> 方法，其流程应该要包含以下三步工作：</p>
<ol>
<li>复制类字典</li>
<li>初始化对象属性</li>
<li>返回对象</li>
</ol>
<p>其中，第一步与第三步的工作，对于每个类而言，都几乎是一样的，所以在 vimloo 中将
其提炼为 <code>class#new()</code> 函数，可为每个自定义类处理通用事务。但是第二步的初始化，
显然是每个类有独立需求的。因此，建议每个类文件再写个 <code>#ctor()</code> 函数专司初始化
，这就叫做构造函数。</p>
<p>仍以上文的 <code>subclass</code> 为例，将其创建函数与构造函数并列展示如下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subclass.vim
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#new</span><span>(</span><span style="color:#b48ead;">...</span><span>) abort
</span><span>   </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#8fa1b3;">class#new</span><span>(</span><span style="color:#bf616a;">s:class</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000</span><span>)
</span><span>   </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">l:obj
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subclass#ctor</span><span>(this, </span><span style="color:#b48ead;">...</span><span>) abort
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">0</span><span> &gt; </span><span style="color:#d08770;">0
</span><span>        </span><span style="color:#96b5b4;">let a</span><span style="color:#b48ead;">:</span><span>this</span><span style="color:#b48ead;">.</span><span>value = </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">endif
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>理论上，<code>#ctor()</code> 函数内的初始化代码插入到 <code>#new()</code> 函数中也是可以的。不过为了
保持 <code>#new()</code> 函数的简单统一，同时为了支持其他间接创建对象的需要，故将构造函数
<code>#ctor()</code> 独立出来。需要注意的是，<code>#ctor()</code> 函数不是由当前类文件的 <code>#new()</code> 函
数直接调用的，而是间接由通用的 <code>class#new()</code> 函数调用。不过可变参数 <code>...</code> 的意
义在这两个函数之间保持一致，即 <code>#ctor()</code> 内的 <code>a:1</code> 与 <code>#new()</code> 内的 <code>a:1</code> 是
相同意义的参数。在构造函数 <code>#ctor()</code> 中，对象已经被创建出来，第一个参数 <code>a:this</code>
就代表这个刚创建的对象。构造函数一般不由用户直接调用，也不必返回值，只要在创建
函数 <code>#new()</code> 中返回对象即可。</p>
<p>一般情况下，在自定义类文件中，建议同时提供创建函数与构造函数，各司其职。但是构
造函数不是必须的，尤其是对象属性很少，或能接受每个对象都采用相同的初始值。甚至
创建函数也不是必须的，因为也能从通用的 <code>class#new()</code> 函数中创建指定类的对象。
例如，以下两个语句是等效的：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">let</span><span> obj = </span><span style="color:#8fa1b3;">class#subclass#new</span><span>(</span><span style="color:#d08770;">100</span><span>)
</span><span>: </span><span style="color:#96b5b4;">let</span><span> obj = </span><span style="color:#8fa1b3;">class#new</span><span>(</span><span style="color:#a3be8c;">&#39;class#subclass&#39;</span><span>, [</span><span style="color:#d08770;">100</span><span>])
</span></code></pre>
<p>显然，使用类文件自己特定版本的 <code>#new()</code> 函数创建对象更简洁，意义更明确。不过通
用的 <code>class#new()</code> 函数也适用于在程序运行需要动态创建不同类别的对象的情况。如
果传入的第一个参数是类名字符串，则相应的类文件中必须定义 <code>#class()</code> 函数（上例
就是 <code>class#subclass#class()</code>） 才能获取其类定义 <code>s:class</code>。此外，要让
<code>class#new()</code> 能正确调用构造函数，也依赖于类字典 <code>s:class</code> 保存了类名属性
<code>_name_</code>。</p>
<p>对于子类的构造函数，写起来略为复杂些。因为你肯定期望能复用基类（母类）的构造函
数初始化继承自母类的那部分数据属性。<code>class.vim</code> 提供了一个 <code>class#Suctor()</code> 函
数用于获取一个类的母类的构造函数（引用）。于是 <code>subsubclass</code> 的构造函数可写成
如下形式：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/subsubclass.vim
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#subsubclass#ctor</span><span>(this, </span><span style="color:#b48ead;">...</span><span>) abort
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:Suctor</span><span> = </span><span style="color:#8fa1b3;">class#Suctor</span><span>(</span><span style="color:#bf616a;">s:class</span><span>)
</span><span>    call </span><span style="color:#8fa1b3;">call</span><span>(</span><span style="color:#bf616a;">l:Suctor</span><span>, </span><span style="color:#8fa1b3;">extend</span><span>([</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>this], </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000</span><span>))
</span><span style="color:#65737e;">    &quot; Todo: 子类的其他对象属性初始化
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>其中，<code>call()</code> 内置函数的用法不算简单，请参考文档 <code>:h call()</code>。如果你确知母类
的构造函数没有做什么实质性的初始化工作（甚至未提供构造函数），也可以省去调用母
类构造函数的步骤。如果硬编码调用母类的构造函数，如 <code>class#subclass#ctor()</code> ，
也不是不可以，但显然太过僵硬了，且写法上也未必比利用 <code>class#Suctor()</code> 省多少。
在上例中，直接将所有的参数 <code>a:000</code> 传给母类的构造函数处理。在实践中，可能只需
要部分参数传给母类，如果这部分参数正好是可变参数的前面几个，那么直接传 <code>a:000</code>
也可能是正常的。在其他其他情况下，可能要对参数作某些预处理再传给母类的构造函数
。</p>
<p>在那些没有自动回收垃圾机制的面向对象语言（如 C++）中，与构造函数相应地，还有析
构函数。VimL 脚本语言显然是能自动回收垃圾的，不须由程序员作此负担。不过 VimL
在处理有环引用（如双向链表、树、图等复杂结构）中，垃圾回收会有滞后。为此，也可
以在自定义类文件中写个“析构函数”，命名为 <code>#dector()</code>，用于打断对象内部的环引用。
当确实用不到一个对象时（往往是在函数末尾），调用 <code>class#delete(object)</code>，它会
自动调用相应类文件的 <code>#dector()</code> 方法，然后当这个对象离开作用域时，就能立即被
回收了。vim 也有个内置的函数 <code>garbagecollect()</code> 可触发立即回收垃圾，但它可能要
用到搜索判断环引用的复杂算法。如程序员能帮它的回收机制打断环引用，也应是善事，
尽管这是可选的，不是必须的。</p>
<h3 id="lei-de-wai-bao-yu-jian-hua-shi-yong">类的外包与简化使用</h3>
<p>有了以上讨论的 vimloo 提供的面向对象功能，我们就能根据具体的功能需要，设计自定
义的类（体系）了，然后创建对象完成实际的工作。</p>
<p>不过还有个小问题，就是类名可能太长，书写不便。假如有这么个类，全名是
<code>class#long#path#topic#subject</code>。用户在使用这个类时，每次创建对象都得调用
<code>class#long#path#topic#subject#new()</code> 函数。这已经算麻烦的了，如果以后想重构，
想对类重命名或移动存放目录路径，那每个创建对象的地方都还得作相应修改，那就不仅
麻烦，也更易遗漏出错了。</p>
<p>为此，vimloo 再提供一个 <code>class#use()</code> 函数。先直接看用法示例：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/autoload/class/long/path/topic/subject.vim
</span><span>
</span><span style="color:#65737e;">&quot; 正常类定义，略
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">class#long#path#topic#subject#use</span><span>(</span><span style="color:#b48ead;">...</span><span>) abort
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">class#use</span><span>(</span><span style="color:#bf616a;">s:class</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span style="color:#d08770;">000</span><span>)
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/vimllearn/useclass.vim
</span><span>
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:CPack</span><span> = </span><span style="color:#8fa1b3;">class#long#path#topic#subject#use</span><span>()
</span><span style="color:#65737e;">&quot; 或
</span><span style="color:#65737e;">&quot; let s:CPack = class#use(&#39;class#long#path#topic#subject&#39;)
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:foo</span><span>() abort
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#bf616a;">s:CPack</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">new</span><span>()
</span><span style="color:#65737e;">    &quot; Todo:
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">s:bar</span><span>() abort
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:obj</span><span> = </span><span style="color:#bf616a;">s:CPack</span><span style="color:#b48ead;">.</span><span style="color:#8fa1b3;">new</span><span>()
</span><span style="color:#65737e;">    &quot; Todo:
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>简言之，<code>class#use()</code> 创建会创建一个字典，默认情况下有以下几个键：</p>
<ul>
<li><code>class</code>：就是引用在类文件中定义的类字典 <code>s:class</code></li>
<li><code>new</code>  ：函数引用，相关类文件的创建函数 <code>#new()</code></li>
<li><code>isobject</code> ：函数引用，相关类文件的创建函数 <code>#isobject()</code></li>
</ul>
<p>就是将某个类定义及两个最重要的自动加载函数（的引用）打包在另一个字典中，可以提
供额外参数（函数名列表，不含 <code>#</code> 路径前缀）指定打包其他的自动加载函数，但 <code>class</code>
是不需要指定，必然被打包在其内的。由于这仅是作了一层简单的包装，提供给外部使用
，故简称为“外包”机制。注意类的方法（如 <code>s:class.method()</code>）是不需要外包的，因
为那是通过之后创建的实例对象访问的。</p>
<p>通过这种外包，用户代码就可大为简化了。例如可以在脚本开始将要用到的类的外包保存
在一个脚本局部变量，如 <code>s:CPack</code>，然后在该脚本内就可以用 <code>s:CPack.new()</code> 创建该
类的对象了。这是自动加载函数的引用，同样可以触发相关类文件的自动加载。如果此后
类名发生了修改，或者就是想试用另一个类，也只要修改开始的一处代码而已。甚至在创
建子类时，也可以利用外包书写，如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:CPack</span><span> = </span><span style="color:#8fa1b3;">class#long#path#topic#subject#use</span><span>()
</span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">s:class</span><span> = </span><span style="color:#8fa1b3;">class#old</span><span>(</span><span style="color:#bf616a;">s:CPack</span><span style="color:#b48ead;">.</span><span>class)
</span><span style="color:#65737e;">&quot; 等效于
</span><span style="color:#65737e;">&quot; let s:class = class#long#path#topic#subject#old()
</span></code></pre>
<p>另外要提示的是，<code>class#use()</code> 函数会记录已经被外包使用的类。所以在正常运行时，
每个类只会创建一个外包，在多个脚本中使用同一个类的外包时，并不会增加额外的开销
。</p>
<h3 id="lei-wen-jian-kuang-jia-zi-dong-sheng-cheng">类文件框架自动生成</h3>
<p>从以上内容可感知，创建一个自定义类文件，有着大致相似的框架，主要包含以下几部分
内容：</p>
<ul>
<li>创建 <code>s:class</code> 字典，可以是简单的空字典或继承其他类；</li>
<li>为 <code>s:class</code> 增加数据属性键，可用初始值约定数据类型；</li>
<li>为 <code>s:class</code> 创建字典函数，用作类的方法；</li>
<li>提供一些必要的自动加载函数。</li>
</ul>
<p>为了节省键盘录入字符的工作，vimloo 也提供了一些命令，用于根据模板文件生成类定
义文件的基本框架。这可节省 VimL 类开发者的大量工作，通过命令生成基础代码（甚至
可以再自定义映射，一键生成）后，只要再填充必要的类定义实现即可。</p>
<ul>
<li><code>:ClassNew {name}</code> 当前目录在某个 <code>autoload/</code> 或其子目录时可用，提供一个文件
名参数，将新建一个 <code>.vim</code> 文件，并根据该文件名创建一个类。</li>
<li><code>:ClassAdd</code> 当正在编辑 <code>autoload/</code> 或其子目录下的某个 <code>.vim</code> 文件时，用该命
令向当前文件添加一个类定义。</li>
<li><code>:ClassPart {option}</code> 与 <code>:ClassAdd</code> 类似，但只根据选项生成部分代码，而非全
部代码，用于补遗。</li>
</ul>
<p>类定义的框架模板文件位于 vimloo 项目的 <code>autoload/tempclass.vim</code>，这也是一个符合
VimL 语法的脚本，同时也是个五脏俱全的类定义文件。该文件的每个段落开始有行注释
，注释行末尾是类似 <code>-x</code> 的选项字符串，其中若小写字母表示默认生成这段代码，大写
字母表示不生成这段代码。但以上命令可附加额外选项覆盖默认行为，多个选项字母拼在
一起当作一个参数传入。</p>
<p>若使用时还遇到疑问，请参考 vimloo 项目的说明文档或帮助文档。</p>


                </div>
            </div>

            <div class="prev-link">
                
    
        
        
        <a class="previous" href="https://lymslive.github.io/vimllearn/ch07-object-program/"><</a>
    

            </div>

            <div class="next-link">
                
    
        
        
        
        
            
            
            
        
            
            
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
                    
                
            
        
            
            
                <a class="next" href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/">></a>
                
                
            
            
                
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
        
            
            
            
                
            
                
            
                
            
        
            
            
            
        
    

            </div>
        </div>

        
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/elasticlunr.min.js"></script>
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/search_index.en.js"></script>
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/book.js"></script>
        
    </body>

</html>

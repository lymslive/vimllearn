<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      
    

      <title></title>

      
      

      <!-- CSS -->
      
      <link rel="stylesheet" href="https://lymslive.github.io/vimllearn/book.css">
      

      
      
    </head>

    <body>
        <div class="menu">
            
            
            <nav role="navigation">
                <ul>
                    
                        
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch00-prefcace/">
                                    
                                    前言
                                </a>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/">
                                    
                                    第一章 VimL 语言主要特点
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn1-hello-world/">
                                                    
                                                    1.1 Hello World 的四种写法
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn2-from-ex-command/">
                                                    
                                                    1.2 同源 ex 命令行
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn3-week-type-strong-scope/">
                                                    
                                                    1.3 弱类型强作用域
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch01-viml-feature/sn4-autoload-schema/">
                                                    
                                                    1.4 自动加载脚本机制
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/">
                                    
                                    第二章 VimL 语言基本语法
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn1-variable-type/">
                                                    
                                                    2.1 变量与类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn2-comapare-condition/">
                                                    
                                                    2.2 选择与比较
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn3-loop-iterate/">
                                                    
                                                    2.3 循环与迭代
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn4-function-call/">
                                                    
                                                    2.4 函数定义与使用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch02-viml-grammar/sn5-exception-error/">
                                                    
                                                    2.5 异常处理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/">
                                    
                                    第三章 Vim 常用命令
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn1-option-set/">
                                                    
                                                    3.1 选项设置
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn2-key-remap/">
                                                    
                                                    3.2 快捷键重映射
                                                </a>
                                            </li>
                                        
                                            <li class="active">
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn3-custom-command/">
                                                    
                                                    3.3 自定义命令
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn4-execute-normal/">
                                                    
                                                    3.4 execute 与 normal
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn5-autocmd-event/">
                                                    
                                                    3.5 自动命令与事件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn6-debug-command/">
                                                    
                                                    3.6 调试命令
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/">
                                    
                                    第四章 VimL 数据结构进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn1-list-string/">
                                                    
                                                    4.1 再谈列表与字符串
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn2-dictionary/">
                                                    
                                                    4.2 通用的字典结构
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn3-nest-compose/">
                                                    
                                                    4.3 嵌套组合与扩展
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch04-viml-datastruct/sn4-regex-apply/">
                                                    
                                                    4.4 正则表达式
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/">
                                    
                                    第五章 VimL 函数进阶
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn1-variable-argument/">
                                                    
                                                    5.1 可变参数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn2-function-refer/">
                                                    
                                                    5.2 函数引用
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn3-dict-function/">
                                                    
                                                    5.3 字典函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn4-closure-lambda/">
                                                    
                                                    5.4 闭包函数
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch05-viml-function/sn5-autoload-function/">
                                                    
                                                    5.5 自动函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/">
                                    
                                    第六章 VimL 内建函数使用
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn1-operate-datatype/">
                                                    
                                                    6.1 操作数据类型
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn2-operate-edit-object/">
                                                    
                                                    6.2 操作编辑对象
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn3-operate-filesystem/">
                                                    
                                                    6.3 操作系统文件
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch06-builtin-function/sn4-other-utility/">
                                                    
                                                    6.4 其他实用函数
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/">
                                    
                                    第七章 VimL 面向对象编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn1-object-intro/">
                                                    
                                                    7.1 面向对象的简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn2-dict-object/">
                                                    
                                                    7.2 字典即对象 
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch07-object-program/sn3-object-organize/">
                                                    
                                                    7.3 自定义类的组织管理
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/">
                                    
                                    第八章 VimL 异步编程特性
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn1-asynchronous-intro/">
                                                    
                                                    8.1 异步工作简介
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn2-asynchronous-job/">
                                                    
                                                    8.2 使用异步任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn3-channle-job/">
                                                    
                                                    8.3 使用通道控制任务
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch08-viml-asynchronous/sn4-internal-terminal/">
                                                    
                                                    8.4 使用配置内置终端
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/">
                                    
                                    第九章 VimL 混合编程
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn1-extern-filter/">
                                                    
                                                    9.1 用外部语言写过滤器
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn2-extern-interface/">
                                                    
                                                    9.2 外部语言接口编程
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch09-viml-mix-program/sn3-perl-interface/">
                                                    
                                                    9.3 Perl 语言接口开发
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/">
                                    
                                    第十章 Vim 插件管理与开发
                                </a>
                                
                                    <ul>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn1-plugin-directory/">
                                                    
                                                    10.1 典型插件的目录规范
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn2-plugin-manager/">
                                                    
                                                    10.2 插件管理器插件介绍
                                                </a>
                                            </li>
                                        
                                            <li >
                                                <a href="https://lymslive.github.io/vimllearn/ch10-viml-plugin-develop/sn3-plugin-devflow/">
                                                    
                                                    10.3 插件开发流程指引
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                        
                            
                            <li >
                                
                                <a href="https://lymslive.github.io/vimllearn/chA1-postfcace/">
                                    
                                    结语
                                </a>
                                
                            </li>
                        
                    
                </ul>
            </nav>
            
            
        </div>

        <div class="page">
            <div class="page__header">
                <div class="menu-icon">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                
                <span class="search-icon">🔎</span>
                
            </div>

            <div class="page__content">
                
                <div class="search-container">
                    <input id="search" type="search" placeholder="Search..">
                    <div class="search-results">
                        <div class="search-results__header"></div>
                        <ul class="search-results__items"></ul>
                    </div>
                </div>
                
                <div class="book-content">
                    
    <h1>3.3 自定义命令</h1>
    <!-- ## 3.3 自定义命令 -->
<h3 id="ming-ling-yu-fa">命令语法</h3>
<p>定义命令与定义映射的用法其实很相似：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>:</span><span style="color:#96b5b4;">command</span><span> {lhs} {rhs}
</span></code></pre>
<p>只不过在使用自定义命令时，<code>{lhs}</code> 是直接输入到命令行中的，当你按下回车时，vim
就将 <code>{lhs}</code> 替换为 <code>{rhs}</code> 再执行。所以这在形式上与下面这个映射等效：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">nnoremap</span><span> :{lhs}&lt;CR&gt; :{rhs}&lt;CR&gt;
</span></code></pre>
<p>当然，由于 <code>:command</code> 所支持的参数与 <code>:map</code> 大相径庭，并不期望你真的按这方式将
自定义命令改成映射。实际上，Vim 的帮助文档中这样描述自定义命令的语法的：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>:</span><span style="color:#96b5b4;">command</span><span> {cmd} {rep}
</span></code></pre>
<p><code>:command!</code> 加个叹号修饰则表示重新定义命令 <code>{cmd}</code>，否则若之前已定义 <code>{cmd}</code>
命令，<code>:command</code> 原版会报错。这是为了保护已定义不被覆盖，当你确实要覆盖时，请
加 <code>!</code> 后缀。在实践中，一般都是在脚本中定义命令，建议只用 <code>!</code> 即可，尤其是在开
发阶段需要调试脚本时，加上 <code>!</code> 方便很多。</p>
<p>大部分命令的 <code>!</code> 修饰版都是表示强制执行，忽略错误的意思。但上一节介绍的 <code>:map!</code> 
的意义太奇葩，建议直接忘记 <code>:map!</code> 的用法。</p>
<p><code>:command</code> 命令的退化用法是一致的：</p>
<ul>
<li><code>:command {cmd}</code> 列出以 <code>{cmd}</code> 开头的自定义命令；</li>
<li><code>:command</code> 列出所有自定义命令；</li>
</ul>
<p>Vim 的内置命令都是小写的（除了 <code>:Next</code> 与 <code>:X</code> <code>:Print</code>），所以要求自定义命令
名 <code>{cmd}</code> 只能以大写字母开头，其后就类似 VimL 变量名的要求了。然而也不建议在
命令名中使用数字，因为这可能与数字参数混淆。</p>
<p>内置命令可以缩写（这与上节的缩写映射不是同个东西），在没有歧义时，只要输入命令
名的前几个字母就可以了。自定义命令 <code>{cmd}</code> 同样可获得此基本福利。不过内置命令
还有更好的福利，就是钦定的缩写，比如 <code>s</code> 是替换命令 <code>substitute</code> 的缩写，但它
不会与 <code>set</code> 发生歧义，而 <code>set</code> 的缩写是 <code>se</code>。自定义命令却无此特性，只能按基
本规则，输入尽可能多的前缀字符来达到唯一确定命令名的目的。不过缩写只建议在命令
行中使用，在脚本中尽量使用全名。</p>
<h3 id="ming-ling-shu-xing">命令属性</h3>
<p>在自定义命令时，可支持多种属性，就像 <code>:map</code> 的特殊参数（用 <code>&lt;&gt;</code> 括起来的）。但
是在 <code>:command</code> 中，以一个 <code>-</code> 引导一个属性（更像 shell 命令行的选项）。所有属
性必须出现在命令名 <code>{cmd}</code> 之前。</p>
<ul>
<li><code>-buffer</code> 局部命令，只能用于当前 buffer。</li>
<li><code>-bang</code> 该自定义命令允许有 <code>!</code> 后缀修饰。</li>
<li><code>-register</code> 第一个参数允许是寄存器名。</li>
<li><code>-bar</code> 该自定义命令后面允许用 <code>|</code> 分隔，接续另一个命令。在这种情况下，<code>{rep}</code>
参数内就不能有 <code>|</code> 了，否则会出现解析歧义。</li>
</ul>
<p>以上这几个属性，只有 <code>-buffer</code> 是常用的，并且建议能局部化时尽量局部化。其他
的属性则较少用到。<code>-bang</code> 与 <code>-register</code> 只相当于某种特殊参数，而在同一行中用
<code>|</code> 使用多个语句（命令）的骚操作，能不用尽量不用。</p>
<p>然后，命令还支持几个复杂的属性，用 <code>-attribute=value</code> 表示，允许为属性指定值，
要注意的是等号前后没有空格，而将整体当作 <code>:command</code> 命令的一个参数。</p>
<ul>
<li>参数个数，自定义命令 <code>{cmd}</code> 允许多少个参数：
<ul>
<li><code>-nargs=0</code> 这是默认行为，不指定该属性就表示命令不接受参数；</li>
<li><code>-nargs=1</code> 仅接受一个参数；</li>
<li><code>-nargs=*</code> 接受 0 或多个参数；</li>
<li><code>-nargs=?</code> 接受 0 或 1 个参数；</li>
<li><code>-nargs=+</code> 接受 1 或多个参数。</li>
</ul>
</li>
</ul>
<p>按常规用法，多个参数用空格分隔（或制表符）。但如果只有一个参数，末尾的空格会被
认为是参数的一部分。否则若要参数中包含空格，请用 <code>\</code> 转义。</p>
<ul>
<li>
<p>范围数字释义，是否允许在命令之前加上一个或两个（以逗号分隔）数字：</p>
<ul>
<li><code>-range</code> 允许两个地址参数或一个数字参数。不加该属性时，自定义命令默认不接
收数字或地址参数。但这只是允许，可选加或不加，也不提供默认数字或地址。</li>
<li><code>-range=%</code> 允许地址参数，且默认是全 buffer，相当于 <code>1,$</code>。</li>
<li><code>-range=N</code> 允许一个数字参数，默认是 <code>N</code>，只能用在命令名之前。</li>
<li><code>-count=N</code> 与 <code>-range=N</code> 类似，不过数字参数不仅可以出现在命令名之前，也可
以出现在命令名之后（相当于第一个参数）。<code>-count</code> 与 <code>-count=0</code> 等效。不过
注意，<code>-range</code> 属性与 <code>-count</code> 属性是互斥的，最好只用其中一个属性。</li>
</ul>
</li>
<li>
<p>特殊地址<code>.</code> <code>$</code> <code>%</code> 所表示的范围（在允许 <code>-range</code> 时）：</p>
<ul>
<li><code>-addr=lines</code> 这也是默认行为，取当前 buffer 文本行的范围。</li>
<li><code>-addr=arguments</code> 指打开 vim 时命令行的文件名参数（其实也可以更改）。</li>
<li><code>-addr=buffers</code> 指所有打开过的 buffer。</li>
<li><code>-addr=loaded_buffers</code> 仅指当前加载的 buffer，在某个窗口中显示的 buffer。</li>
<li><code>-addr=windows</code> 取所有窗口列表的范围，仅限当前标签页。</li>
<li><code>-addr=tabs</code> 取所有标签页范围。</li>
</ul>
</li>
</ul>
<p>注意，<code>-addr</code> 属性必须要与 <code>-range</code> 联用才有意义。它要说明的是当命令的地址参数
使用 <code>.</code>（当前）<code>$</code>（最后）<code>%</code>（所有）是参照什么集合而言的。例如定义如下命令：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span> -range CmdA {rhs}
</span><span>: </span><span style="color:#96b5b4;">command </span><span>-range=</span><span style="color:#b48ead;">% </span><span>-addr=buffers CmdB {rhs}
</span><span>: </span><span style="color:#96b5b4;">command </span><span>-range=</span><span style="color:#b48ead;">% </span><span>-addr=tabs CmdT {rhs}
</span></code></pre>
<p>则使用命令时，<code>:.,$CmdA</code> 表示用命令 <code>CmdA</code> 处理当前 buffer 内当前行到最后一行
之间的文本行。<code>:CmdB</code> 表示处理所有 buffer，因为 <code>-range</code> 的默认范围是 <code>%</code> 表示
所有，而 <code>-addr</code> 表示所有的集合是指所有 buffer。同样，<code>:.,$CmdT</code> 表示处理从当
前标签页到最后一个标签页，虽然 <code>-range=%</code> 表示默认所有，但使用时可以自己加个特
定的地址参数呀。</p>
<h3 id="ming-ling-bu-quan">命令补全</h3>
<p>自定义命令还有个最复杂的属性，是有关补全特性的。值得单独拿出来讨论。</p>
<p>Vimer 初学者倾向于使用映射，可能较少用到自定义命令。但是随着对 Vim 深入使用与
理解，可能就会发觉键盘的映射资源是有限的，尤其是要有规律地组织许多容易记住的映
射会有瓶颈。这时不妨将眼光投入到自定义命令中。虽然使用命令没有映射那么快，但只
不过多加冒号与回车，就几乎有了无限的扩展可能。而且，在命令行中，不仅命令名可以
补全，命令参数也可以补全，这就大大减少了记忆负担。</p>
<p><code>-complete</code> 属性就是用于指定命令如何补全参数的，其取值范围非常广，这里仅介绍几
种主要的补全行为，全部列表请参考 <code>:help :command-complete</code>：</p>
<ul>
<li><code>-complete=file</code> 按文件（包含目录）补全，就像 <code>:edit </code> 命令按 <code>&lt;Tab&gt;</code> 后会补
全文件名那样。</li>
<li><code>-complete=option</code> 补全选项名。</li>
<li><code>-complete=help</code> 补全帮助主题。</li>
<li><code>-complete=shellcmd</code> 补全外部 shell 可用的命令。</li>
<li><code>-complete=tag</code> 补全标签，类似 <code>:tag </code> 所需的参数。</li>
<li><code>-complete=filetype</code> 补全文件类型名。</li>
</ul>
<p>总之，如果自定义命令期望它的参数是某一类意义上的参数，就可以指定 <code>-complete</code>
属性为相应的值，以方便输入参数。当然，如果你定义的某个命令要实现比较复杂的功能
，vim 预设提供的补全行为都不满足要求的话，还可以指定一个函数来实现补全。</p>
<ul>
<li><code>-complete=custom,{func}</code></li>
<li><code>-complete=customlist,{func}</code></li>
</ul>
<p>这也叫做自定义补全。要注意的是，<code>=</code> 与 <code>,</code> 前后都没有空格，在 <code>custom,</code> 或
<code>customlist,</code>后直接接一个函数名。</p>
<p>当 <code>-complete</code> 属性值是 <code>custom</code> 时，函数要求返回一个以回车 <code>\n</code> 分隔的字符串
，每一行是一个候选补全项。且 vim 会自动匹配比较光标前已经输入的部分参数前缀，
进行一些过滤。</p>
<p>当 <code>-complte</code> 属性值是 <code>customlist</code> 时，函数要求返回一个列表，每个元素是候选补
全项。但 Vim 不会自动对参数前缀过滤，可能要求用户自己在函数中过滤。</p>
<p>在这两种情况，补全函数的定义都是类似的，它应该接收三个参数：</p>
<ol>
<li><code>a:ArgLead</code> 光标之前的部分参数前缀，</li>
<li><code>a:CmdLine</code> 整个命令行文本，</li>
<li><code>a:CursorPos</code> 当前光标在命令行的位置（按字节计，从1开始）。</li>
</ol>
<p>当用户按下补全键（一般是<code>&lt;Tab&gt;</code>），Vim 会自动将这三个参数传给自定义补全函数。
用户在这个函数实现可利用这三个参数所提供的信息（也许不一定要用到全部），返回合
适的候选补全项。</p>
<h3 id="ming-ling-shi-xian">命令实现</h3>
<p>我们将自定义名之后的 <code>{rep}</code> 参数部分称为命令实现。它可以是一串简单的替换文本
，但真正有趣的是它可用一些特殊标记来表示特殊的或动态的内容。这里的特殊标记也用
尖括号 <code>&lt;&gt;</code> 括起，所支持的有意义的标记可能依赖于前面的的命令属性。</p>
<ul>
<li><code>&lt;line1&gt;</code> <code>&lt;line2&gt;</code> 分别表示地址参数的两个数字（一般是第一行与最后一行）。含
<code>-range</code> 属性的命令才能接收这两个参数。</li>
<li><code>&lt;count&gt;</code> 就是由 <code>-count</code> 属性提供的数字参数。</li>
<li><code>&lt;bang&gt;</code> 支持 <code>-bang</code> 属性的命令，如果使用时加了 <code>!</code> 修饰，则在 <code>{rep}</code> 中的
<code>&lt;bang&gt;</code> 标记转换为 <code>!</code> 字符，否则就没任何效果。</li>
<li><code>&lt;register&gt;</code> 或简写为 <code>&lt;reg&gt;</code>，支持 <code>-register</code> 属性的命令，表示可选的寄存器参
数；否则也没任何效果（加上引号 <code>&quot;&lt;reg&gt;&quot;</code> 才表示空字符串）。</li>
<li><code>&lt;lt&gt;</code> 代表左尖括号 <code>&lt;</code>，避免尖括号的特殊意义。比如想在 <code>{rep}</code> 中字面地呈现
<code>&lt;bang&gt;</code> 这几个字符串，而不是转化为 <code>!</code> 字符，就可用 <code>&lt;lt&gt;bang&gt;</code>。</li>
</ul>
<p>先举个简单的例子，我们已经知道 <code>:map!</code> 命令是列出某类映射。虽然上文说过应该忘
记这个命令，不过正因为它安全无害，不妨再拿来作为演示讲解。首先定义这个命令：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span>! MAP </span><span style="color:#96b5b4;">map
</span></code></pre>
<p>这个自定义命令似乎很无趣，不过用大写版的 <code>:MAP</code> 代替内置的 <code>:map</code>。请试试在命
令中输入 <code>:MAP</code> 并回车执行，其结果与直接使用 <code>:map</code> 是一样的。试试 <code>:MAP!</code> 呢
？Vim 会报错，说这个命令不支持 <code>!</code>。那么重定义一下这个命令：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span>! -bang MAP </span><span style="color:#96b5b4;">map</span><span>&lt;bang&gt;
</span></code></pre>
<p>现在，应该 <code>:MAP</code> 与 <code>:MAP!</code> 命令都可以使用了，并且分别与 <code>:map</code> 与 <code>:map!</code> 等
价。这就是 <code>&lt;bang&gt;</code> 用于命令实现参数 <code>{rep}</code> 中的代表意义。同时，如果你没有定
义其他以 <code>MA</code> 开头的命令，那么我们这个自定义命令简写成 <code>:MA</code> 或 <code>:MA!</code> 也是可
以的。</p>
<p>由于这个自定义没有加 <code>-nargs</code> 属性，默认是不能接收参数的，所以若试图用 <code>:MAP lhs rhs</code> 来定义映射会失败。但是，加了参数属性后，又如何在 <code>{rep}</code> 中使用相应的
参数呢？这就是 <code>&lt;args&gt;</code> 标记的用途，同时这有多个变种：</p>
<ul>
<li><code>&lt;args&gt;</code> 将用户在自定义命令后输入的参数原样替换到 <code>{rep}</code> 中。不过若命令还有
<code>-count</code> 或 <code>-register</code> 属性的话，前面的属性应该由 <code>&lt;count&gt;</code> 或 <code>&lt;reg&gt;</code> 捕获
，而 <code>&lt;args&gt;</code> 只表示剩余的参数。</li>
<li><code>&lt;q-args&gt;</code> 与 <code>&lt;args&gt;</code> 一样，先捕获所有参数，然后将所有参数用引号括起来作为
一个字符串表达式参数。如果没有参数，这将是一个空字符串（包含引号如 <code>&quot;&quot;</code>）。</li>
<li><code>&lt;f-args&gt;</code> 也与 <code>&lt;q-args&gt;</code> 一样，只不过将捕获的参数分隔成适用于函数调用时小括
号内的参数列表，所以是将每个参数分别引起，并用逗号分隔。这在 <code>{rep}</code> 实现中
调用一个函数中非常有用。如果没有参数，则所调用函数的小括号内也没有任何东西，
即以空参数调用。</li>
</ul>
<p>现在继续来改造我们的自定义命令 <code>MAP</code>：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span>! -bang -nargs=</span><span style="color:#b48ead;">*</span><span> MAP </span><span style="color:#96b5b4;">map</span><span>&lt;bang&gt; &lt;args&gt;
</span></code></pre>
<p>这样，<code>:MAP</code> 与 <code>:MAP!</code> 可以继续用，而且也可以用它来定义映射了，例如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: MAP &lt;buffer&gt; x dd
</span></code></pre>
<p>这里，用自己的 <code>:MAP</code> 来定义一个映射，将 <code>x</code> 删除一个字符的功能改为删一行
。不过由于只为试验，所以加 <code>&lt;buffer&gt;</code> 定义成局部映射（注意区别，定义局部命令用
<code>-buffer</code> 语法）。</p>
<p>由于我们在定义 <code>MAP</code> 时允许它接收任意个参数 <code>-nargs=*</code>。所以在 <code>:MAP &lt;buffer&gt; x dd</code> 这个使用场合下，<code>:MAP</code> 的所有参数 <code>&lt;buffer&gt; x dd</code> 替换在定义 <code>MAP</code> 时
<code>&lt;args&gt;</code> 的位置上，也就相当于执行 <code>:map &lt;buffer&gt; x dd</code>。可以试下执行完，再按
<code>x</code> 是不是实现了预期效果，同时也可以用 <code>:MAP x</code> 或 <code>:map x</code> 查看下将 <code>x</code> 定义
成啥样的映射了。</p>
<p>在这个示例中，如果将定义 <code>MAP</code> 时的 <code>&lt;args&gt;</code> 改成 <code>&lt;q-args&gt;</code> 或 <code>&lt;f-args&gt;</code> 的
话，结果就不正确了，不能仿拟 <code>:map</code> 命令了。在实现复杂命令时，后两个参数变种标
记才更有用，作为函数调用的参数。不过这较为复杂，留待下一小节再论。这里先探讨一下
<code>&lt;register&gt;</code> 参数的使用，假设继续为 <code>MAP</code> 命令添加这个属性：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span>! -bang -register -nargs=</span><span style="color:#b48ead;">*</span><span> MAP &lt;register&gt;</span><span style="color:#96b5b4;">map</span><span>&lt;bang&gt; &lt;args&gt;
</span></code></pre>
<p>先将原来定义的 <code>x</code> 映射删除：<code>:unmap &lt;buffer&gt; x</code>。然后再用新的 <code>:MAP</code> 命令定义
<code>x</code> 映射，不过在参数 <code>&lt;buffer&gt;</code> 前额外加个参数 <code>n</code>：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: MAP n &lt;buffer&gt; x dd 
</span></code></pre>
<p>结果是相当于只定义了普通模式下的映射 <code>:nmap &lt;buffer&gt; x dd</code>。你可以用 <code>:map x</code>
查看一下 <code>x</code> 的映射定义确认。并且对比一下 <code>:MAP &lt;buffer&gt; X dd</code> 不加 <code>n</code> 的用法
。</p>
<p>结论就是 <code>&lt;register&gt;</code> 不过是捕获了第一个参数，<code>&lt;args&gt;</code> 捕获其他参数。而 <code>MAP</code>
的定义 <code>&lt;register&gt;map&lt;bang&gt; &lt;args&gt;</code> 表明是将第一个参数直接拼在 <code>map</code> 之前作为
映射命令的模式前缀限定，而将其他参数用空格分开后作为 <code>:map</code> 命令的参数了。</p>
<p>这样看来，<code>&lt;register&gt;</code> 似乎很名副其实呀。那么我们再尝试下将 <code>un</code> 作为 <code>:MAP</code> 的
第一个参数，看它会不会变成 <code>:unmap</code> 用于删除映射：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: MAP un &lt;buffer&gt; x
</span><span>: MAP un &lt;buffer&gt; X
</span></code></pre>
<p>然而，这次 vim 报错了，提示 <code>umap n &lt;buffer&gt; x</code> 不是一个命令。由些可见，
<code>&lt;register&gt;</code> 只捕获的第一个字母 <code>u</code>，然后将剩余的东西都当成 <code>&lt;args&gt;</code> 了。因为
寄存器名都是一个字母啊。</p>
<p>vim 有些内置命令如 <code>:del</code> <code>:yank</code> <code>:put</code> 支持后面接一个寄存器名（比如 <code>a</code>），
表示对相应的寄存器操作，相当于普通模式的命令 <code>&quot;ad</code> <code>&quot;ay</code> <code>&quot;ap</code>。自定义命令就可
用 <code>&lt;regsiter&gt;</code> 实现类似的特性，使得自定义命令能像内置命令一样使用。只不过，
<code>&lt;register&gt;</code> 只能捕获参数中的第一个字母，把它当成是寄存器名，传给 <code>{rep}</code> 实现
部分，却无法控制 <code>{rep}</code> 如何处理这个字母。因为 <code>:map</code> 命令的模式前缀限定恰好
也只是一个字母，所以我们的 <code>:MAP</code> 就可以用 <code>&lt;register&gt;</code> 进行伪装了。你可以自行
尝试 <code>:MAP i</code> <code>:MAP c</code> 等用法应该也是有效的。</p>
<p>上一节也提前，使用映射命令，尽量使用更安全的 <code>:noremap</code>，所以再重定义命令：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span>! -bang -register -nargs=</span><span style="color:#b48ead;">*</span><span> MAP &lt;register&gt;</span><span style="color:#96b5b4;">noremap</span><span>&lt;bang&gt; &lt;args&gt;
</span></code></pre>
<p>要测试这个命令是否有效，可定义如下映射：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: MAP n &lt;buffer&gt; x xx 
</span></code></pre>
<p>再按 <code>x</code> 看看是否能正确只删除两个字符，还是会发生无尽循环故障（如果有这问题，
按 <code>&lt;Ctrl-c&gt;</code> 中断即可）。</p>
<p>再次提醒：这里讨论不断“优化” <code>:MAP</code> 命令，只为说明 <code>:command</code> 自定义命令的用法
与机制。正常使用 vim 下，应该没必要定义这么个命令呀。</p>
<h3 id="zi-ding-yi-ming-ling-diao-yong-han-shu">自定义命令调用函数</h3>
<p>除了很简单的命令，可以调用 vim 既有的内置命令（可能进行必要的包装修饰）外，大
多实用的自定义命令，都是通过调用函数来实现命令要求的功能。这不仅可以实现很复杂
的功能，也容易扩展，还使得用法简明易记，因为它一般是如下的形式结构之一：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>:</span><span style="color:#96b5b4;">command</span><span>! {cmd} call </span><span style="color:#8fa1b3;">WorkFunc</span><span>(&lt;f-args&gt;)
</span><span>:</span><span style="color:#96b5b4;">command</span><span>! {cmd} call </span><span style="color:#8fa1b3;">WorkFunc</span><span>(&lt;q-args&gt;)
</span></code></pre>
<p>当使用自定义命令 <code>{cmd}</code> 时，它后面的命令行参数就会传入实际工作的函数
<code>WorkFunc()</code> 中。<code>&lt;f-args&gt;</code> 按空格分隔多个参数，然后分别引为字符串参数传入，如
果要在参数中包含空格，要用 <code>\ </code> 转义，要传入 <code>\</code> 就要用两个反斜杠即 <code>\\</code>。而
<code>&lt;q-args&gt;</code> 则简单粗暴，将 <code>{cmd}</code> 的所有参数，也就是其后跟着的所有内容当一个
字符串参数传入。在 <code>{cmd}</code> 之后没有任何参数时，<code>&lt;q-args&gt;</code> 也至少传入一个空字符
串参数（<code>WorkFunc(&quot;&quot;)</code>），但 <code>&lt;f-args&gt;</code> 就不传入任何参数了（<code>WorkFunc()</code>）。</p>
<p>注意：传入 <code>WorkFunc()</code> 的参数必定是字符串类型，但由于 VimL 弱类型与自动转换，
如果一个参数像数字，那么在函数体内将它当作数字处理也完全没有问题。</p>
<p>按 <code>&lt;f-args&gt;</code> 方式调用函数更为常见。<code>&lt;q-args&gt;</code> 可能只用于比较特殊的需要，然后
要自己在函数体内解析字符串参数。另外，<code>&lt;f-args&gt;</code> 只适用于函数调用参数，用在其
他地方的意义不明显，且易出错。而 <code>&lt;q-args&gt;</code> 用于函数参数之外也可能是有意义的。
本小节暂时不讨论 <code>&lt;q-args&gt;</code> 的使用。</p>
<h4 id="shi-yong-range">使用 range</h4>
<p>首先我们需要一个工作函数。不妨复用在 2.4 节讲述函数时使用的给文本行编号的示例
函数吧，取那个支持 <code>range</code> 特性的版本，并改名为 <code>NumberLine</code> 重贴于下：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#65737e;">&quot; File: ~/.vim/vimllearn/fcommand.vim
</span><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">NumberLine</span><span>() abort range
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">l:line </span><span style="color:#b48ead;">in </span><span style="color:#8fa1b3;">range</span><span>(</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>firstline, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>lastline)
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sLine</span><span> = </span><span style="color:#8fa1b3;">getline</span><span>(</span><span style="color:#bf616a;">l:line</span><span>)
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sLine</span><span> = </span><span style="color:#bf616a;">l:line </span><span style="color:#b48ead;">. </span><span style="color:#a3be8c;">&#39; &#39; </span><span style="color:#b48ead;">. </span><span style="color:#bf616a;">l:sLine
</span><span>        call </span><span style="color:#8fa1b3;">setline</span><span>(</span><span style="color:#bf616a;">l:line</span><span>, </span><span style="color:#bf616a;">l:sLine</span><span>)
</span><span>    </span><span style="color:#b48ead;">endfor
</span><span style="color:#b48ead;">endfunction
</span></code></pre>
<p>然后定义一个命令也叫 <code>NumberLine</code>，用以调用该函数，命令名与函数不需要相同，只
是懒得另起名字，同时也想说明，命令与函数重名完全没问题，因为它们是完全不是同类
概念：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span>: </span><span style="color:#96b5b4;">command</span><span>! -range=</span><span style="color:#b48ead;">%</span><span> NumberLine &lt;line1&gt;,&lt;line2&gt;call </span><span style="color:#8fa1b3;">NumberLine</span><span>()
</span></code></pre>
<p>注意到 <code>NumberLine()</code> 函数不支持显式参数，但可接收隐式的地址参数。而命令
<code>:NumberLine</code> 正好定义为支持 <code>-range</code> 属性，这就要将捕获的地址参数
<code>&lt;line1&gt;,&lt;line2&gt;</code> 放在 <code>call</code> 之前，由 <code>call</code> 把地址参数传给 <code>NumberLine()</code> 函
数的 <code>a:firstline</code> 与 <code>a:lastline</code>。</p>
<p>现在我们就可以来试用这个自定义命令了。如果直接在命令行输入 <code>:NumberLine</code> 回车
执行，它会对当前 buffer 的所有文本行编号。因为 <code>-buffer</code> 属性的默认值 <code>%</code> 就表
示所有行，相当于 <code>1,$</code>。如果我们按行可视模式 <code>V</code> 选择几行，再按 <code>:NumberLine</code>
，命令行中实际输入的是 <code>:'&lt;,'&gt;NumberLine</code> ，它就只会对选择的行进行编号。</p>
<h4 id="shi-yong-count">使用 count</h4>
<p>接着讨论下与 <code>-range</code> 相似但互斥的 <code>-count</code> 属性。<code>&lt;count&gt;</code> 只有一个数字参数，
即可放在命令之前，也可以放在命令之后（甚至对是否有空格分隔不敏感）。很多 vim
内置命令的数字表示重复次数，不过在自定义命令中，<code>&lt;count&gt;</code> 只负责捕获传递这个数
字参数，并无法控制后续命令如何使用这个数字，就如 <code>&lt;register&gt;</code> 一样。</p>
<p>我们另外写个函数，用于对当前行及后面若干行进行相对编号，即当前行号是 <code>0</code>，下一
行是 <code>1</code> 等（类似 <code>:set relativenumber</code>）。</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">NumberRelate</span><span>(count) abort
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:cursor</span><span> = </span><span style="color:#8fa1b3;">line</span><span>(</span><span style="color:#a3be8c;">&#39;.&#39;</span><span>)
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:eof</span><span> = </span><span style="color:#8fa1b3;">line</span><span>(</span><span style="color:#a3be8c;">&#39;$&#39;</span><span>)
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">l:count </span><span style="color:#b48ead;">in </span><span style="color:#8fa1b3;">range</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>count)
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:line</span><span>  = </span><span style="color:#bf616a;">l:cursor</span><span> + </span><span style="color:#bf616a;">l:count
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">l:line</span><span> &gt; </span><span style="color:#bf616a;">l:eof
</span><span>            break
</span><span>        </span><span style="color:#b48ead;">endif
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sLine</span><span> = </span><span style="color:#8fa1b3;">getline</span><span>(</span><span style="color:#bf616a;">l:line</span><span>)
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sLine</span><span> = </span><span style="color:#bf616a;">l:count </span><span style="color:#b48ead;">. </span><span style="color:#a3be8c;">&#39; &#39; </span><span style="color:#b48ead;">. </span><span style="color:#bf616a;">l:sLine
</span><span>        call </span><span style="color:#8fa1b3;">setline</span><span>(</span><span style="color:#bf616a;">l:line</span><span>, </span><span style="color:#bf616a;">l:sLine</span><span>)
</span><span>    </span><span style="color:#b48ead;">endfor
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">command</span><span>! -count NumberRelate call </span><span style="color:#8fa1b3;">NumberRelate</span><span>(&lt;count&gt;)
</span></code></pre>
<p>同时也定义一个相应的命令。试试效果？如果直接运行 <code>:NumberRelate</code> ，由于
<code>-count</code> 的默认值是 0，所以只对当前行编号为 0。如果对选区运行
<code>:'&lt;,'&gt;NumberRalate</code>，给命令提供了两个地址参数？但该命令只接收一个数字参数啊，
vim 只会将后面那个地址参数 <code>'&gt;</code> 当作数字参数 <code>&lt;count&gt;</code> 传给函数
<code>NumberRelate()</code> 的参数。同时也可以手动输入数字如 <code>:3NumberRelate</code> 或
<code>:NumberRelate3</code> 都会对当前行及后面3行编号。其中 <code>NumberRelate3</code> 的写法可能会
有歧义，如果恰好还有个自定义命名叫叫 <code>NumberRelate3</code>。所以最好用
<code>:NumberRelate 3</code> 来调用。也正是这个原因，不建议在命令名中混入数字。</p>
<p>至于 Vim 为什么允许命令与数字参数粘在一起使用，主要是因为要快捷输入。很多最常
用的命令都是有单字母缩写的，而与数字参数的组合使用又极频繁。在这种情况情况下多
敲一个空格的性价比太低了（我的命令才一个字母呢），所以就把空格吃了吧。</p>
<p>这个示例也说明，自定义命令调用函数时，参数不一定要用 <code>&lt;f-args&gt;</code> 或 <code>&lt;q-args&gt;</code>
，混入其他任何特殊标记也是可以的，只要展开替换后符号函数调用语法即可。再比如，
<code>call WorkFunc(&lt;bang&gt;)</code> 是非法的，因为展开是 <code>call WorkFunc(!)</code>，但 <code>call WorkFunc(&quot;&lt;bang&gt;&quot;)</code> 是合法的，因为展开后是 <code>call WorkFunc(&quot;!&quot;)</code>。而 <code>&lt;count&gt;</code>
（其实也包括 <code>&lt;line1&gt;</code> <code>&lt;line2&gt;</code>）可直接放入函数括号内，是因为它们会展开成一个
数字。</p>
<h4 id="shi-yong-f-args">使用 f-args</h4>
<p>前面两例所用的函数都不接收参数，如果函数要求参数，就用 <code>&lt;f-args&gt;</code> 传入吧。假设
更改为文本行编号的需求，在数字编号后还允许加个后缀字符，像 <code>1.</code> <code>1)</code> 之类的，
同时可以定制分隔编号与原文本之间的空格数量。我们重写 <code>NumberLine</code> 函数，让它接
收两个参数：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#b48ead;">function</span><span>! </span><span style="color:#8fa1b3;">NumberLine</span><span>(postfix, count) abort range
</span><span>    </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sep</span><span> = </span><span style="color:#8fa1b3;">repeat</span><span>(</span><span style="color:#a3be8c;">&#39; &#39;</span><span>, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>count) </span><span style="color:#65737e;">&quot; 生成含 count 个空格的字符串
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">l:line </span><span style="color:#b48ead;">in </span><span style="color:#8fa1b3;">range</span><span>(</span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>firstline, </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>lastline)
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sLine</span><span> = </span><span style="color:#8fa1b3;">getline</span><span>(</span><span style="color:#bf616a;">l:line</span><span>)
</span><span>        </span><span style="color:#96b5b4;">let </span><span style="color:#bf616a;">l:sLine</span><span> = </span><span style="color:#bf616a;">l:line </span><span style="color:#b48ead;">. </span><span style="color:#96b5b4;">a</span><span style="color:#b48ead;">:</span><span>postfix </span><span style="color:#b48ead;">. </span><span style="color:#bf616a;">l:sep </span><span style="color:#b48ead;">. </span><span style="color:#bf616a;">l:sLine
</span><span>        call </span><span style="color:#8fa1b3;">setline</span><span>(</span><span style="color:#bf616a;">l:line</span><span>, </span><span style="color:#bf616a;">l:sLine</span><span>)
</span><span>    </span><span style="color:#b48ead;">endfor
</span><span style="color:#b48ead;">endfunction
</span><span>
</span><span style="color:#96b5b4;">command</span><span>! -range=</span><span style="color:#b48ead;">% </span><span>-nargs=+ NumberLine &lt;line1&gt;,&lt;line2&gt;call </span><span style="color:#8fa1b3;">NumberLine</span><span>(&lt;f-args&gt;)
</span></code></pre>
<p>然后也重定义命令 <code>:NumberLine</code>，为其增加 <code>-nargs</code> 属性，然后用 <code>&lt;f-args&gt;</code> 传给
函数调用。注意虽然可以用 <code>-nargs=1</code> 限定允许一个参数，但不支持 <code>-nargs=2</code> 限定
恰好两个参数，只能用不定数量的 <code>-nargs=*</code> 或 <code>-nargs=+</code>。此时若只用
<code>:NumberLine</code> 命令执行，会报错说参数太少，加上两个命令行参数后如 <code>:NumberLine ) 4</code> 就能正常工作了，这表示编号样式为 <code>1)</code> 然后接 4 个空格。</p>
<p>注意到 <code>NumberLine()</code> 函数虽然也有个 <code>count</code> 参数。但与上例不同，不能用
<code>-count</code> 属性与 <code>&lt;count&gt;</code> 参数。首先是因为 <code>-count</code> 与 <code>-range</code> 属性只能用一个
，不能共存。其次这里的 <code>count</code> 参数与大多 vim 内置命令对数字参数的解释很有些不
同，只是恰好用了这个形参名而已。因此不要滥用 <code>&lt;count&gt;</code> 参数，能直接用
<code>&lt;f-args&gt;</code> 是最简洁明了的。</p>
<p>如果工作函数 <code>WorkFunc()</code> 没有 <code>range</code> 属性，不处理地址范围的话，那么自定义命
令时，也不要加 <code>-range</code> 属性，而后面的调用函数写法也更加简单。</p>
<p>另外，如果工作函数是脚本作用域的函数，如 <code>s:WorkFunc()</code>，则在 <code>{rep}</code> 部分中调
用写成 <code>&lt;SID&gt;WorkFunc()</code>，高版本的 vim 也可以直接用 <code>s:WorkFunc()</code>。不过上节的
映射命令 <code>:map</code>，却只能用 <code>&lt;SID&gt;</code> 而不能用 <code>s:</code>。</p>
<h3 id="wei-ming-ling-shi-li">*微命令实例</h3>
<p>本节内容所用的命令示例，主要为阐述概念，也许并无实用性。我在大量使用映射后，也
开始对命令有所偏爱了。为了使命令输入尽可能方便，我将常用命令也定义很短的几个大
写字母，并称之为“微命令”。实现脚本放在了 github 上，有兴趣的可以参考，传送门在
此：https://github.com/lymslive/autoplug/tree/master/autoload/microcmd</p>
<p>如果命令名较长，输入不便时，也可以继续使用映射来触发命令，甚至可以将最常用的命
令参数也一并包含在映射中。</p>


                </div>
            </div>

            <div class="prev-link">
                
    
        
        
        <a class="previous" href="https://lymslive.github.io/vimllearn/ch03-viml-command/"><</a>
    

            </div>

            <div class="next-link">
                
    
        <a class="next" href="https://lymslive.github.io/vimllearn/ch03-viml-command/sn4-execute-normal/">></a>
    

            </div>
        </div>

        
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/elasticlunr.min.js"></script>
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/search_index.en.js"></script>
            
            <script type="text/javascript" src="https://lymslive.github.io/vimllearn/book.js"></script>
        
    </body>

</html>
